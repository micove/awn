/* dock-manager-api.c generated by valac 0.12.1, the Vala compiler
 * generated from dock-manager-api.vala, do not modify */

/*
 * Copyright (C) 2010 Michal Hruby <michal.mhr@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA.
 *
 * Authored by Michal Hruby <michal.mhr@gmail.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <dbus/dbus-glib.h>
#include <stdlib.h>
#include <string.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <dbus/dbus.h>
#include <task-manager.h>
#include <task-icon.h>
#include <task-window.h>
#include <task-launcher.h>
#include <gtk/gtk.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include <task-item.h>
#include "dock-manager-api.h"
#include <libawn/vala-utils.h>
#include <string>

typedef struct _DBusObjectVTable _DBusObjectVTable;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _DockManagerDBusInterfaceDBusProxy DockManagerDBusInterfaceDBusProxy;
typedef DBusGProxyClass DockManagerDBusInterfaceDBusProxyClass;
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
typedef struct _DockItemDBusInterfaceDBusProxy DockItemDBusInterfaceDBusProxy;
typedef DBusGProxyClass DockItemDBusInterfaceDBusProxyClass;

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))

#define _g_slist_free0(var) ((var == NULL) ? NULL : (var = (g_slist_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Block1Data Block1Data;
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))

struct _DBusObjectVTable {
    void (*register_object)(DBusConnection*, const char*, void*);
};

struct _DockManagerDBusInterfaceDBusProxy {
    DBusGProxy parent_instance;
    gboolean disposed;
};

struct _DockItemDBusInterfaceDBusProxy {
    DBusGProxy parent_instance;
    gboolean disposed;
};

struct _TaskManagerDispatcherPrivate {
    TaskManager* _manager;
};


struct _TaskIconDispatcherPrivate {
    TaskIcon* icon;
    gchar* _object_path;
};

struct _Block1Data {
    int _ref_count_;
    TaskIconDispatcher* self;
    gint id;
};


static gpointer task_manager_dispatcher_parent_class = NULL;
static DockManagerDBusInterfaceIface* task_manager_dispatcher_dock_manager_dbus_interface_parent_iface = NULL;
static gpointer task_icon_dispatcher_parent_class = NULL;
static gint task_icon_dispatcher_counter = 1;
static DockItemDBusInterfaceIface* task_icon_dispatcher_dock_item_dbus_interface_parent_iface = NULL;

static void g_cclosure_user_marshal_VOID__BOXED(GClosure* closure, GValue* return_value, guint n_param_values, const GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
static void _vala_dbus_register_object(DBusConnection* connection, const char* path, void* object);
static void _vala_dbus_unregister_object(gpointer connection, GObject* object);
void dock_manager_dbus_interface_dbus_register_object(DBusConnection* connection, const char* path, void* object);
void _dock_manager_dbus_interface_dbus_unregister(DBusConnection* connection, void* _user_data_);
DBusHandlerResult dock_manager_dbus_interface_dbus_message(DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_dock_manager_dbus_interface_introspect(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_dock_manager_dbus_interface_property_get_all(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_dock_manager_dbus_interface_get_capabilities(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_dock_manager_dbus_interface_get_items(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_dock_manager_dbus_interface_get_items_by_name(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_dock_manager_dbus_interface_get_items_by_desktop_file(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_dock_manager_dbus_interface_get_items_by_pid(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_dock_manager_dbus_interface_get_item_by_xid(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_dock_manager_dbus_interface_awn_set_visibility(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_dock_manager_dbus_interface_awn_register_proxy_item(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_dock_manager_dbus_interface_item_added(GObject* _sender, const char* path, DBusConnection* _connection);
static void _dbus_dock_manager_dbus_interface_item_removed(GObject* _sender, const char* path, DBusConnection* _connection);
extern "C" GType dock_manager_dbus_interface_dbus_proxy_get_type(void) G_GNUC_CONST;
static void _dbus_handle_dock_manager_dbus_interface_item_added(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_handle_dock_manager_dbus_interface_item_removed(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message);
DBusHandlerResult dock_manager_dbus_interface_dbus_proxy_filter(DBusConnection* connection, DBusMessage* message, void* user_data);
enum  {
    DOCK_MANAGER_DBUS_INTERFACE_DBUS_PROXY_DUMMY_PROPERTY
};
static gchar** dock_manager_dbus_interface_dbus_proxy_get_capabilities(DockManagerDBusInterface* self, int* result_length1, GError** error);
static char** dock_manager_dbus_interface_dbus_proxy_get_items(DockManagerDBusInterface* self, int* result_length1, GError** error);
static char** dock_manager_dbus_interface_dbus_proxy_get_items_by_name(DockManagerDBusInterface* self, const gchar* name, int* result_length1, GError** error);
static char** dock_manager_dbus_interface_dbus_proxy_get_items_by_desktop_file(DockManagerDBusInterface* self, const gchar* desktop_file, int* result_length1, GError** error);
static char** dock_manager_dbus_interface_dbus_proxy_get_items_by_pid(DockManagerDBusInterface* self, gint pid, int* result_length1, GError** error);
static char* dock_manager_dbus_interface_dbus_proxy_get_item_by_xid(DockManagerDBusInterface* self, gint64 xid, GError** error);
static void dock_manager_dbus_interface_dbus_proxy_awn_set_visibility(DockManagerDBusInterface* self, const gchar* win_name, gboolean visible, GError** error);
static char* dock_manager_dbus_interface_dbus_proxy_awn_register_proxy_item(DockManagerDBusInterface* self, const gchar* desktop_file, const gchar* uri, GError** error);
static void dock_manager_dbus_interface_dbus_proxy_dock_manager_dbus_interface__interface_init(DockManagerDBusInterfaceIface* iface);
static void _vala_dock_manager_dbus_interface_dbus_proxy_get_property(GObject* object, guint property_id, GValue* value, GParamSpec* pspec);
static void _vala_dock_manager_dbus_interface_dbus_proxy_set_property(GObject* object, guint property_id, const GValue* value, GParamSpec* pspec);
DockItemDBusInterface* dock_item_dbus_interface_dbus_proxy_new(DBusGConnection* connection, const char* name, const char* path);
GType dock_item_dbus_interface_get_type(void) G_GNUC_CONST;
void dock_item_dbus_interface_dbus_register_object(DBusConnection* connection, const char* path, void* object);
void _dock_item_dbus_interface_dbus_unregister(DBusConnection* connection, void* _user_data_);
DBusHandlerResult dock_item_dbus_interface_dbus_message(DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_dock_item_dbus_interface_introspect(DockItemDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_dock_item_dbus_interface_property_get(DockItemDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_dock_item_dbus_interface_property_get_all(DockItemDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_dock_item_dbus_interface_add_menu_item(DockItemDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_dock_item_dbus_interface_remove_menu_item(DockItemDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_dock_item_dbus_interface_update_dock_item(DockItemDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_dock_item_dbus_interface_menu_item_activated(GObject* _sender, gint id, DBusConnection* _connection);
extern "C" GType dock_item_dbus_interface_dbus_proxy_get_type(void) G_GNUC_CONST;
static void _dbus_handle_dock_item_dbus_interface_menu_item_activated(DockItemDBusInterface* self, DBusConnection* connection, DBusMessage* message);
DBusHandlerResult dock_item_dbus_interface_dbus_proxy_filter(DBusConnection* connection, DBusMessage* message, void* user_data);
enum  {
    DOCK_ITEM_DBUS_INTERFACE_DBUS_PROXY_DUMMY_PROPERTY
};
static gint dock_item_dbus_interface_dbus_proxy_add_menu_item(DockItemDBusInterface* self, GHashTable* menu_hints, GError** error);
static void dock_item_dbus_interface_dbus_proxy_remove_menu_item(DockItemDBusInterface* self, gint id, GError** error);
static void dock_item_dbus_interface_dbus_proxy_update_dock_item(DockItemDBusInterface* self, GHashTable* hints, GError** error);
static gchar* dock_item_dbus_interface_dbus_proxy_get_desktop_file(DockItemDBusInterface* self);
static gchar* dock_item_dbus_interface_dbus_proxy_get_uri(DockItemDBusInterface* self);
static void dock_item_dbus_interface_dbus_proxy_dock_item_dbus_interface__interface_init(DockItemDBusInterfaceIface* iface);
static void _vala_dock_item_dbus_interface_dbus_proxy_get_property(GObject* object, guint property_id, GValue* value, GParamSpec* pspec);
static void _vala_dock_item_dbus_interface_dbus_proxy_set_property(GObject* object, guint property_id, const GValue* value, GParamSpec* pspec);
GType task_manager_dispatcher_get_type(void) G_GNUC_CONST;
#define TASK_MANAGER_DISPATCHER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_TASK_MANAGER_DISPATCHER, TaskManagerDispatcherPrivate))
enum  {
    TASK_MANAGER_DISPATCHER_DUMMY_PROPERTY,
    TASK_MANAGER_DISPATCHER_MANAGER
};
static char** task_manager_dispatcher_list_to_object_path_array(GSList* list, int* result_length1);
const gchar* task_icon_dispatcher_get_object_path(TaskIconDispatcher* self);
static gchar** task_manager_dispatcher_real_get_capabilities(DockManagerDBusInterface* base, int* result_length1, GError** error);
static char** task_manager_dispatcher_real_get_items(DockManagerDBusInterface* base, int* result_length1, GError** error);
TaskManager* task_manager_dispatcher_get_manager(TaskManagerDispatcher* self);
static char** task_manager_dispatcher_real_get_items_by_name(DockManagerDBusInterface* base, const gchar* name, int* result_length1, GError** error);
static char** task_manager_dispatcher_real_get_items_by_desktop_file(DockManagerDBusInterface* base, const gchar* desktop_file, int* result_length1, GError** error);
static char** task_manager_dispatcher_real_get_items_by_pid(DockManagerDBusInterface* base, gint pid, int* result_length1, GError** error);
static char* task_manager_dispatcher_real_get_item_by_xid(DockManagerDBusInterface* base, gint64 xid, GError** error);
static void task_manager_dispatcher_real_awn_set_visibility(DockManagerDBusInterface* base, const gchar* win_name, gboolean visible, GError** error);
static void _g_free0_(gpointer var);
static void _vala_GValue_free(GValue* self);
static void __vala_GValue_free0_(gpointer var);
static char* task_manager_dispatcher_real_awn_register_proxy_item(DockManagerDBusInterface* base, const gchar* desktop_file, const gchar* uri, GError** error);
static void task_manager_dispatcher_set_manager(TaskManagerDispatcher* self, TaskManager* value);
static void task_manager_dispatcher_finalize(GObject* obj);
void task_manager_dispatcher_dbus_register_object(DBusConnection* connection, const char* path, void* object);
void _task_manager_dispatcher_dbus_unregister(DBusConnection* connection, void* _user_data_);
DBusHandlerResult task_manager_dispatcher_dbus_message(DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_task_manager_dispatcher_introspect(TaskManagerDispatcher* self, DBusConnection* connection, DBusMessage* message);
static void _vala_task_manager_dispatcher_get_property(GObject* object, guint property_id, GValue* value, GParamSpec* pspec);
static void _vala_task_manager_dispatcher_set_property(GObject* object, guint property_id, const GValue* value, GParamSpec* pspec);
#define TASK_ICON_DISPATCHER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_TASK_ICON_DISPATCHER, TaskIconDispatcherPrivate))
enum  {
    TASK_ICON_DISPATCHER_DUMMY_PROPERTY,
    TASK_ICON_DISPATCHER_OBJECT_PATH
};
static TaskManagerDispatcher* task_icon_dispatcher_get_manager_proxy(TaskIconDispatcher* self);
static void task_icon_dispatcher_emit_item_added(TaskIconDispatcher* self);
static gint task_icon_dispatcher_real_add_menu_item(DockItemDBusInterface* base, GHashTable* menu_hints, GError** error);
static Block1Data* block1_data_ref(Block1Data* _data1_);
static void block1_data_unref(Block1Data* _data1_);
static void _lambda0_(GtkMenuItem* w, Block1Data* _data1_);
static void __lambda0__gtk_menu_item_activate(GtkMenuItem* _sender, gpointer self);
static void task_icon_dispatcher_real_remove_menu_item(DockItemDBusInterface* base, gint id, GError** error);
static void task_icon_dispatcher_real_update_dock_item(DockItemDBusInterface* base, GHashTable* hints, GError** error);
static void task_icon_dispatcher_finalize(GObject* obj);
void task_icon_dispatcher_dbus_register_object(DBusConnection* connection, const char* path, void* object);
void _task_icon_dispatcher_dbus_unregister(DBusConnection* connection, void* _user_data_);
DBusHandlerResult task_icon_dispatcher_dbus_message(DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_task_icon_dispatcher_introspect(TaskIconDispatcher* self, DBusConnection* connection, DBusMessage* message);
static void _vala_task_icon_dispatcher_get_property(GObject* object, guint property_id, GValue* value, GParamSpec* pspec);
static void _vala_task_icon_dispatcher_set_property(GObject* object, guint property_id, const GValue* value, GParamSpec* pspec);

static const DBusObjectPathVTable _dock_manager_dbus_interface_dbus_path_vtable = {_dock_manager_dbus_interface_dbus_unregister, dock_manager_dbus_interface_dbus_message};
static const _DBusObjectVTable _dock_manager_dbus_interface_dbus_vtable = {dock_manager_dbus_interface_dbus_register_object};
static const DBusObjectPathVTable _dock_item_dbus_interface_dbus_path_vtable = {_dock_item_dbus_interface_dbus_unregister, dock_item_dbus_interface_dbus_message};
static const _DBusObjectVTable _dock_item_dbus_interface_dbus_vtable = {dock_item_dbus_interface_dbus_register_object};
static const DBusObjectPathVTable _task_manager_dispatcher_dbus_path_vtable = {_task_manager_dispatcher_dbus_unregister, task_manager_dispatcher_dbus_message};
static const _DBusObjectVTable _task_manager_dispatcher_dbus_vtable = {task_manager_dispatcher_dbus_register_object};
static const DBusObjectPathVTable _task_icon_dispatcher_dbus_path_vtable = {_task_icon_dispatcher_dbus_unregister, task_icon_dispatcher_dbus_message};
static const _DBusObjectVTable _task_icon_dispatcher_dbus_vtable = {task_icon_dispatcher_dbus_register_object};

gchar** dock_manager_dbus_interface_get_capabilities(DockManagerDBusInterface* self, int* result_length1, GError** error)
{
    return DOCK_MANAGER_DBUS_INTERFACE_GET_INTERFACE(self)->get_capabilities(self, result_length1, error);
}


char** dock_manager_dbus_interface_get_items(DockManagerDBusInterface* self, int* result_length1, GError** error)
{
    return DOCK_MANAGER_DBUS_INTERFACE_GET_INTERFACE(self)->get_items(self, result_length1, error);
}


char** dock_manager_dbus_interface_get_items_by_name(DockManagerDBusInterface* self, const gchar* name, int* result_length1, GError** error)
{
    return DOCK_MANAGER_DBUS_INTERFACE_GET_INTERFACE(self)->get_items_by_name(self, name, result_length1, error);
}


char** dock_manager_dbus_interface_get_items_by_desktop_file(DockManagerDBusInterface* self, const gchar* desktop_file, int* result_length1, GError** error)
{
    return DOCK_MANAGER_DBUS_INTERFACE_GET_INTERFACE(self)->get_items_by_desktop_file(self, desktop_file, result_length1, error);
}


char** dock_manager_dbus_interface_get_items_by_pid(DockManagerDBusInterface* self, gint pid, int* result_length1, GError** error)
{
    return DOCK_MANAGER_DBUS_INTERFACE_GET_INTERFACE(self)->get_items_by_pid(self, pid, result_length1, error);
}


char* dock_manager_dbus_interface_get_item_by_xid(DockManagerDBusInterface* self, gint64 xid, GError** error)
{
    return DOCK_MANAGER_DBUS_INTERFACE_GET_INTERFACE(self)->get_item_by_xid(self, xid, error);
}


void dock_manager_dbus_interface_awn_set_visibility(DockManagerDBusInterface* self, const gchar* win_name, gboolean visible, GError** error)
{
    DOCK_MANAGER_DBUS_INTERFACE_GET_INTERFACE(self)->awn_set_visibility(self, win_name, visible, error);
}


char* dock_manager_dbus_interface_awn_register_proxy_item(DockManagerDBusInterface* self, const gchar* desktop_file, const gchar* uri, GError** error)
{
    return DOCK_MANAGER_DBUS_INTERFACE_GET_INTERFACE(self)->awn_register_proxy_item(self, desktop_file, uri, error);
}


static void g_cclosure_user_marshal_VOID__BOXED(GClosure* closure, GValue* return_value, guint n_param_values, const GValue* param_values, gpointer invocation_hint, gpointer marshal_data)
{
    typedef void (*GMarshalFunc_VOID__BOXED)(gpointer data1, gpointer arg_1, gpointer data2);
    register GMarshalFunc_VOID__BOXED callback;
    register gpointer data1, data2;
    g_return_if_fail(n_param_values == 2);
    GCClosure* cc = reinterpret_cast<GCClosure*>(closure);
    if (G_CCLOSURE_SWAP_DATA(closure)) {
        data1 = closure->data;
        data2 = param_values->data[0].v_pointer;
    } else {
        data1 = param_values->data[0].v_pointer;
        data2 = closure->data;
    }
    callback = (GMarshalFunc_VOID__BOXED)(marshal_data ? marshal_data : cc->callback);
    callback(data1, g_value_get_boxed(param_values + 1), data2);
}


static void dock_manager_dbus_interface_base_init(DockManagerDBusInterfaceIface* iface)
{
    static bool initialized = false;
    if (!initialized) {
        initialized = true;
        g_signal_new("item_added", TYPE_DOCK_MANAGER_DBUS_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, 1, DBUS_TYPE_G_OBJECT_PATH);
        g_signal_new("item_removed", TYPE_DOCK_MANAGER_DBUS_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, 1, DBUS_TYPE_G_OBJECT_PATH);
    }
}


static void _vala_dbus_register_object(DBusConnection* connection, const char* path, void* object)
{
    const _DBusObjectVTable* vtable;
    vtable = g_type_get_qdata(G_TYPE_FROM_INSTANCE(object), g_quark_from_static_string("DBusObjectVTable"));
    if (vtable) {
        vtable->register_object(connection, path, object);
    } else {
        g_warning("Object does not implement any D-Bus interface");
    }
}


static void _vala_dbus_unregister_object(gpointer connection, GObject* object)
{
    char* path = g_object_steal_data((GObject*) object, "dbus_object_path");
    dbus_connection_unregister_object_path(connection, path);
    g_free(path);
}


void _dock_manager_dbus_interface_dbus_unregister(DBusConnection* connection, void* _user_data_)
{
}

static DBusHandlerResult _dbus_dock_manager_dbus_interface_introspect(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    std::string xml_data{"<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n"};
    xml_data += "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"net.launchpad.DockManager\">\n  <method name=\"GetCapabilities\">\n    <arg name=\"result\" type=\"as\" direction=\"out\"/>\n  </method>\n  <method name=\"GetItems\">\n    <arg name=\"result\" type=\"ao\" direction=\"out\"/>\n  </method>\n  <method name=\"GetItemsByName\">\n    <arg name=\"name\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"ao\" direction=\"out\"/>\n  </method>\n  <method name=\"GetItemsByDesktopFile\">\n    <arg name=\"desktop_file\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"ao\" direction=\"out\"/>\n  </method>\n  <method name=\"GetItemsByPid\">\n    <arg name=\"pid\" type=\"i\" direction=\"in\"/>\n    <arg name=\"result\" type=\"ao\" direction=\"out\"/>\n  </method>\n  <method name=\"GetItemByXid\">\n    <arg name=\"xid\" type=\"x\" direction=\"in\"/>\n    <arg name=\"result\" type=\"o\" direction=\"out\"/>\n  </method>\n  <method name=\"AwnSetVisibility\">\n    <arg name=\"win_name\" type=\"s\" direction=\"in\"/>\n    <arg name=\"visible\" type=\"b\" direction=\"in\"/>\n  </method>\n  <method name=\"AwnRegisterProxyItem\">\n    <arg name=\"desktop_file\" type=\"s\" direction=\"in\"/>\n    <arg name=\"uri\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"o\" direction=\"out\"/>\n  </method>\n  <signal name=\"ItemAdded\">\n    <arg name=\"path\" type=\"o\"/>\n  </signal>\n  <signal name=\"ItemRemoved\">\n    <arg name=\"path\" type=\"o\"/>\n  </signal>\n</interface>\n";

    char** children;
    dbus_connection_list_registered(connection, g_object_get_data((GObject*) self, "dbus_object_path"), &children);
    for (int i = 0; children[i]; i++) {
        xml_data = xml_data + "<node name=\"" + children[i] + "\"/>\n";
    }
    dbus_free_string_array(children);
    xml_data += "</node>\n";
    awn::vala_dbus_iter_append_string(&iter, xml_data.c_str());
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_dock_manager_dbus_interface_property_get_all(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter, reply_iter, subiter;
    if (strcmp(dbus_message_get_signature(message), "s")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &reply_iter);
    const char* msg;
    dbus_message_iter_get_basic(&iter, &msg);
    dbus_message_iter_next(&iter);
    char* interface_name = g_strdup(msg);
    if (strcmp(interface_name, "net.launchpad.DockManager") == 0) {
        dbus_message_iter_open_container(&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
        dbus_message_iter_close_container(&reply_iter, &subiter);
    } else {
        dbus_message_unref(reply);
        reply = NULL;
    }
    g_free(interface_name);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_dock_manager_dbus_interface_get_capabilities(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    GError* error = nullptr;
    if (strcmp(dbus_message_get_signature(message), "")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    int result_length1 = 0;
    char** result = dock_manager_dbus_interface_get_capabilities(self, &result_length1, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);

    DBusMessageIter msg_iter;
    dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY, "s", &msg_iter);
    char** ri = result;
    for (int i = 0; i < result_length1; i++) {
        awn::vala_dbus_iter_append_string(&msg_iter, *ri++);
    }
    dbus_message_iter_close_container(&iter, &msg_iter);

    awn::vala_array_free(result, result_length1, (GDestroyNotify) g_free);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_dock_manager_dbus_interface_get_items(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    GError* error;
    char** result;
    int result_length1;
    char** _tmp5_;
    DBusMessageIter _tmp6_;
    int _tmp7_;
    error = NULL;
    if (strcmp(dbus_message_get_signature(message), "")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    result_length1 = 0;
    result = dock_manager_dbus_interface_get_items(self, &result_length1, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    _tmp5_ = result;
    dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY, "o", &_tmp6_);
    for (_tmp7_ = 0; _tmp7_ < result_length1; _tmp7_++) {
        awn::vala_dbus_iter_append_obj_path(&_tmp6_, *_tmp5_++);
    }
    dbus_message_iter_close_container(&iter, &_tmp6_);
    awn::vala_array_free(result, result_length1, (GDestroyNotify) g_free);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}

static DBusHandlerResult _dbus_dock_manager_dbus_interface_get_items_by_name(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    GError* error;
    gchar* name = NULL;
    const char* _tmp9_;
    char** result;
    int result_length1;
    DBusMessageIter _tmp11_;
    int _tmp12_;
    error = NULL;
    if (strcmp(dbus_message_get_signature(message), "s")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    dbus_message_iter_get_basic(&iter, &_tmp9_);
    dbus_message_iter_next(&iter);
    name = g_strdup(_tmp9_);
    result_length1 = 0;
    result = dock_manager_dbus_interface_get_items_by_name(self, name, &result_length1, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    _g_free0(name);
    char** _tmp10_ = result;
    dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY, "o", &_tmp11_);
    for (_tmp12_ = 0; _tmp12_ < result_length1; _tmp12_++) {
        awn::vala_dbus_iter_append_obj_path(&_tmp11_, *_tmp10_++);
    }
    dbus_message_iter_close_container(&iter, &_tmp11_);
    awn::vala_array_free(result, result_length1, (GDestroyNotify) g_free);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_dock_manager_dbus_interface_get_items_by_desktop_file(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    GError* error;
    gchar* desktop_file = NULL;
    const char* _tmp14_;
    char** result;
    int result_length1;
    DBusMessageIter _tmp16_;
    int _tmp17_;
    error = NULL;
    if (strcmp(dbus_message_get_signature(message), "s")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    dbus_message_iter_get_basic(&iter, &_tmp14_);
    dbus_message_iter_next(&iter);
    desktop_file = g_strdup(_tmp14_);
    result_length1 = 0;
    result = dock_manager_dbus_interface_get_items_by_desktop_file(self, desktop_file, &result_length1, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    _g_free0(desktop_file);
    char** _tmp15_ = result;
    dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY, "o", &_tmp16_);
    for (_tmp17_ = 0; _tmp17_ < result_length1; _tmp17_++) {
        awn::vala_dbus_iter_append_obj_path(&_tmp16_, *_tmp15_++);
    }
    dbus_message_iter_close_container(&iter, &_tmp16_);
    awn::vala_array_free(result, result_length1, (GDestroyNotify) g_free);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_dock_manager_dbus_interface_get_items_by_pid(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    GError* error;
    gint pid = 0;
    dbus_int32_t _tmp19_;
    char** result;
    int result_length1;
    char** _tmp20_;
    DBusMessageIter _tmp21_;
    int _tmp22_;
    error = NULL;
    if (strcmp(dbus_message_get_signature(message), "i")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    dbus_message_iter_get_basic(&iter, &_tmp19_);
    dbus_message_iter_next(&iter);
    pid = _tmp19_;
    result_length1 = 0;
    result = dock_manager_dbus_interface_get_items_by_pid(self, pid, &result_length1, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    _tmp20_ = result;
    dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY, "o", &_tmp21_);
    for (_tmp22_ = 0; _tmp22_ < result_length1; _tmp22_++) {
        awn::vala_dbus_iter_append_obj_path(&_tmp21_, *_tmp20_++);
    }
    dbus_message_iter_close_container(&iter, &_tmp21_);
    awn::vala_array_free(result, result_length1, (GDestroyNotify) g_free);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_dock_manager_dbus_interface_get_item_by_xid(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    GError* error;
    gint64 xid = 0LL;
    dbus_int64_t _tmp24_;
    char* result;
    error = NULL;
    if (strcmp(dbus_message_get_signature(message), "x")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    dbus_message_iter_get_basic(&iter, &_tmp24_);
    dbus_message_iter_next(&iter);
    xid = _tmp24_;
    result = dock_manager_dbus_interface_get_item_by_xid(self, xid, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    awn::vala_dbus_iter_append_obj_path(&iter, result);
    _g_free0(result);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_dock_manager_dbus_interface_awn_set_visibility(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    GError* error = nullptr;
    gchar* win_name = NULL;
    const char* _tmp26_;
    dbus_bool_t _tmp27_;
    if (strcmp(dbus_message_get_signature(message), "sb")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    dbus_message_iter_get_basic(&iter, &_tmp26_);
    dbus_message_iter_next(&iter);
    win_name = g_strdup(_tmp26_);
    dbus_message_iter_get_basic(&iter, &_tmp27_);
    dbus_message_iter_next(&iter);
    bool visible = _tmp27_;
    dock_manager_dbus_interface_awn_set_visibility(self, win_name, visible, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    _g_free0(win_name);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_dock_manager_dbus_interface_awn_register_proxy_item(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    GError* error = nullptr;
    gchar* desktop_file = NULL;
    const char* _tmp28_;
    gchar* uri = NULL;
    const char* _tmp29_;
    char* result;
    if (strcmp(dbus_message_get_signature(message), "ss")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    dbus_message_iter_get_basic(&iter, &_tmp28_);
    dbus_message_iter_next(&iter);
    desktop_file = g_strdup(_tmp28_);
    dbus_message_iter_get_basic(&iter, &_tmp29_);
    dbus_message_iter_next(&iter);
    uri = g_strdup(_tmp29_);
    result = dock_manager_dbus_interface_awn_register_proxy_item(self, desktop_file, uri, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    _g_free0(desktop_file);
    _g_free0(uri);
    awn::vala_dbus_iter_append_obj_path(&iter, result);
    _g_free0(result);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


DBusHandlerResult dock_manager_dbus_interface_dbus_message(DBusConnection* connection, DBusMessage* message, void* object)
{
    DBusHandlerResult result;
    result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    if (dbus_message_is_method_call(message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
        result = _dbus_dock_manager_dbus_interface_introspect(object, connection, message);
    } else if (dbus_message_is_method_call(message, "org.freedesktop.DBus.Properties", "GetAll")) {
        result = _dbus_dock_manager_dbus_interface_property_get_all(object, connection, message);
    } else if (dbus_message_is_method_call(message, "net.launchpad.DockManager", "GetCapabilities")) {
        result = _dbus_dock_manager_dbus_interface_get_capabilities(object, connection, message);
    } else if (dbus_message_is_method_call(message, "net.launchpad.DockManager", "GetItems")) {
        result = _dbus_dock_manager_dbus_interface_get_items(object, connection, message);
    } else if (dbus_message_is_method_call(message, "net.launchpad.DockManager", "GetItemsByName")) {
        result = _dbus_dock_manager_dbus_interface_get_items_by_name(object, connection, message);
    } else if (dbus_message_is_method_call(message, "net.launchpad.DockManager", "GetItemsByDesktopFile")) {
        result = _dbus_dock_manager_dbus_interface_get_items_by_desktop_file(object, connection, message);
    } else if (dbus_message_is_method_call(message, "net.launchpad.DockManager", "GetItemsByPid")) {
        result = _dbus_dock_manager_dbus_interface_get_items_by_pid(object, connection, message);
    } else if (dbus_message_is_method_call(message, "net.launchpad.DockManager", "GetItemByXid")) {
        result = _dbus_dock_manager_dbus_interface_get_item_by_xid(object, connection, message);
    } else if (dbus_message_is_method_call(message, "net.launchpad.DockManager", "AwnSetVisibility")) {
        result = _dbus_dock_manager_dbus_interface_awn_set_visibility(object, connection, message);
    } else if (dbus_message_is_method_call(message, "net.launchpad.DockManager", "AwnRegisterProxyItem")) {
        result = _dbus_dock_manager_dbus_interface_awn_register_proxy_item(object, connection, message);
    }
    if (result == DBUS_HANDLER_RESULT_HANDLED) {
        return result;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static void _dbus_dock_manager_dbus_interface_item_added(GObject* _sender, const char* path, DBusConnection* _connection)
{
    const char* _path;
    DBusMessageIter _iter;
    _path = g_object_get_data(_sender, "dbus_object_path");
    DBusMessage* message = dbus_message_new_signal(_path, "net.launchpad.DockManager", "ItemAdded");
    dbus_message_iter_init_append(message, &_iter);
    awn::vala_dbus_iter_append_obj_path(&_iter, path);
    dbus_connection_send(_connection, message, NULL);
    dbus_message_unref(message);
}


static void _dbus_dock_manager_dbus_interface_item_removed(GObject* _sender, const char* path, DBusConnection* _connection)
{
    const char* _path;
    DBusMessageIter _iter;
    _path = g_object_get_data(_sender, "dbus_object_path");
    DBusMessage* message = dbus_message_new_signal(_path, "net.launchpad.DockManager", "ItemRemoved");
    dbus_message_iter_init_append(message, &_iter);
    awn::vala_dbus_iter_append_obj_path(&_iter, path);
    dbus_connection_send(_connection, message, NULL);
    dbus_message_unref(message);
}


void dock_manager_dbus_interface_dbus_register_object(DBusConnection* connection, const char* path, void* object)
{
    if (!g_object_get_data(object, "dbus_object_path")) {
        g_object_set_data(object, "dbus_object_path", g_strdup(path));
        dbus_connection_register_object_path(connection, path, &_dock_manager_dbus_interface_dbus_path_vtable, object);
        g_object_weak_ref(object, _vala_dbus_unregister_object, connection);
    }
    g_signal_connect(object, "item-added", (GCallback) _dbus_dock_manager_dbus_interface_item_added, connection);
    g_signal_connect(object, "item-removed", (GCallback) _dbus_dock_manager_dbus_interface_item_removed, connection);
}


GType dock_manager_dbus_interface_get_type(void)
{
    static volatile gsize dock_manager_dbus_interface_type_id__volatile = 0;
    if (g_once_init_enter(&dock_manager_dbus_interface_type_id__volatile)) {
        static const GTypeInfo g_define_type_info = { sizeof(DockManagerDBusInterfaceIface), (GBaseInitFunc) dock_manager_dbus_interface_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
        GType dock_manager_dbus_interface_type_id;
        dock_manager_dbus_interface_type_id = g_type_register_static(G_TYPE_INTERFACE, "DockManagerDBusInterface", &g_define_type_info, 0);
        g_type_interface_add_prerequisite(dock_manager_dbus_interface_type_id, G_TYPE_OBJECT);
        g_type_set_qdata(dock_manager_dbus_interface_type_id, g_quark_from_string("ValaDBusInterfaceProxyType"), &dock_manager_dbus_interface_dbus_proxy_get_type);
        g_type_set_qdata(dock_manager_dbus_interface_type_id, g_quark_from_static_string("DBusObjectVTable"), (void*)(&_dock_manager_dbus_interface_dbus_vtable));
        g_once_init_leave(&dock_manager_dbus_interface_type_id__volatile, dock_manager_dbus_interface_type_id);
    }
    return dock_manager_dbus_interface_type_id__volatile;
}

extern "C" {
    G_DEFINE_TYPE_EXTENDED(DockManagerDBusInterfaceDBusProxy, dock_manager_dbus_interface_dbus_proxy, DBUS_TYPE_G_PROXY, 0, G_IMPLEMENT_INTERFACE(TYPE_DOCK_MANAGER_DBUS_INTERFACE, dock_manager_dbus_interface_dbus_proxy_dock_manager_dbus_interface__interface_init));
}

DockManagerDBusInterface* dock_manager_dbus_interface_dbus_proxy_new(DBusGConnection* connection, const char* name, const char* path)
{
    DockManagerDBusInterface* self;
    self = g_object_new(dock_manager_dbus_interface_dbus_proxy_get_type(), "connection", connection, "name", name, "path", path, "interface", "net.launchpad.DockManager", NULL);
    return self;
}


static GObject* dock_manager_dbus_interface_dbus_proxy_construct(GType gtype, guint n_properties, GObjectConstructParam* properties)
{
    GObject* self;
    DBusGConnection* connection;
    char* path;
    char* filter;
    self = G_OBJECT_CLASS(dock_manager_dbus_interface_dbus_proxy_parent_class)->constructor(gtype, n_properties, properties);
    g_object_get(self, "connection", &connection, NULL);
    g_object_get(self, "path", &path, NULL);
    dbus_connection_add_filter(dbus_g_connection_get_connection(connection), dock_manager_dbus_interface_dbus_proxy_filter, self, NULL);
    filter = g_strdup_printf("type='signal',path='%s',interface='net.launchpad.DockManager'", path);
    dbus_bus_add_match(dbus_g_connection_get_connection(connection), filter, NULL);
    dbus_g_connection_unref(connection);
    g_free(path);
    g_free(filter);
    return self;
}


static void _dbus_handle_dock_manager_dbus_interface_item_added(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    char* path = NULL;
    const char* _tmp0_;
    if (strcmp(dbus_message_get_signature(message), "o")) {
        return;
    }
    dbus_message_iter_init(message, &iter);
    dbus_message_iter_get_basic(&iter, &_tmp0_);
    dbus_message_iter_next(&iter);
    path = g_strdup(_tmp0_);
    g_signal_emit_by_name(self, "item-added", path);
    g_free(path);
}


static void _dbus_handle_dock_manager_dbus_interface_item_removed(DockManagerDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    char* path = NULL;
    const char* _tmp1_;
    if (strcmp(dbus_message_get_signature(message), "o")) {
        return;
    }
    dbus_message_iter_init(message, &iter);
    dbus_message_iter_get_basic(&iter, &_tmp1_);
    dbus_message_iter_next(&iter);
    path = g_strdup(_tmp1_);
    g_signal_emit_by_name(self, "item-removed", path);
    g_free(path);
}


DBusHandlerResult dock_manager_dbus_interface_dbus_proxy_filter(DBusConnection* connection, DBusMessage* message, void* user_data)
{
    if (dbus_message_has_path(message, dbus_g_proxy_get_path(user_data))) {
        if (dbus_message_is_signal(message, "net.launchpad.DockManager", "ItemAdded")) {
            _dbus_handle_dock_manager_dbus_interface_item_added(user_data, connection, message);
        } else if (dbus_message_is_signal(message, "net.launchpad.DockManager", "ItemRemoved")) {
            _dbus_handle_dock_manager_dbus_interface_item_removed(user_data, connection, message);
        }
    }
    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}


static void dock_manager_dbus_interface_dbus_proxy_dispose(GObject* self)
{
    DBusGConnection* connection;
    if (((DockManagerDBusInterfaceDBusProxy*) self)->disposed) {
        return;
    }
    ((DockManagerDBusInterfaceDBusProxy*) self)->disposed = TRUE;
    g_object_get(self, "connection", &connection, NULL);
    dbus_connection_remove_filter(dbus_g_connection_get_connection(connection), dock_manager_dbus_interface_dbus_proxy_filter, self);
    G_OBJECT_CLASS(dock_manager_dbus_interface_dbus_proxy_parent_class)->dispose(self);
}


static void dock_manager_dbus_interface_dbus_proxy_class_init(DockManagerDBusInterfaceDBusProxyClass* klass)
{
    G_OBJECT_CLASS(klass)->constructor = dock_manager_dbus_interface_dbus_proxy_construct;
    G_OBJECT_CLASS(klass)->dispose = dock_manager_dbus_interface_dbus_proxy_dispose;
    G_OBJECT_CLASS(klass)->get_property = _vala_dock_manager_dbus_interface_dbus_proxy_get_property;
    G_OBJECT_CLASS(klass)->set_property = _vala_dock_manager_dbus_interface_dbus_proxy_set_property;
}


static void dock_manager_dbus_interface_dbus_proxy_init(DockManagerDBusInterfaceDBusProxy* self)
{
}

static gchar** dock_manager_dbus_interface_dbus_proxy_get_capabilities(DockManagerDBusInterface* self, int* result_length1, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter _iter;
    gchar** _result;
    int _result_length1;
    gchar** _tmp2_;
    int _tmp2__length;
    int _tmp2__size;
    int _tmp2__length1;
    DBusMessageIter _tmp3_;
    if (((DockManagerDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return NULL;
    }
    DBusMessage* message = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "net.launchpad.DockManager", "GetCapabilities");
    dbus_message_iter_init_append(message, &_iter);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), message, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(message);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);
        dbus_error_free(&_dbus_error);
        return NULL;
    }
    if (strcmp(dbus_message_get_signature(reply), "as")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "as", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return NULL;
    }
    dbus_message_iter_init(reply, &_iter);
    _result_length1 = 0;
    _tmp2_ = g_new(gchar*, 5);
    _tmp2__length = 0;
    _tmp2__size = 4;
    _tmp2__length1 = 0;
    dbus_message_iter_recurse(&_iter, &_tmp3_);
    for (; dbus_message_iter_get_arg_type(&_tmp3_); _tmp2__length1++) {
        const char* _tmp4_;
        if (_tmp2__size == _tmp2__length) {
            _tmp2__size = 2 * _tmp2__size;
            _tmp2_ = g_renew(gchar*, _tmp2_, _tmp2__size + 1);
        }
        dbus_message_iter_get_basic(&_tmp3_, &_tmp4_);
        dbus_message_iter_next(&_tmp3_);
        _tmp2_[_tmp2__length++] = g_strdup(_tmp4_);
    }
    _result_length1 = _tmp2__length1;
    _tmp2_[_tmp2__length] = NULL;
    dbus_message_iter_next(&_iter);
    _result = _tmp2_;
    *result_length1 = _result_length1;
    dbus_message_unref(reply);
    return _result;
}


static char** dock_manager_dbus_interface_dbus_proxy_get_items(DockManagerDBusInterface* self, int* result_length1, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter _iter;
    char** _result;
    int _result_length1;
    char** _tmp6_;
    int _tmp6__length;
    int _tmp6__size;
    int _tmp6__length1;
    DBusMessageIter _tmp7_;
    if (((DockManagerDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return NULL;
    }
    DBusMessage* message = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "net.launchpad.DockManager", "GetItems");
    dbus_message_iter_init_append(message, &_iter);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), message, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(message);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);
        dbus_error_free(&_dbus_error);
        return NULL;
    }
    if (strcmp(dbus_message_get_signature(reply), "ao")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "ao", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return NULL;
    }
    dbus_message_iter_init(reply, &_iter);
    _result_length1 = 0;
    _tmp6_ = g_new(char*, 5);
    _tmp6__length = 0;
    _tmp6__size = 4;
    _tmp6__length1 = 0;
    dbus_message_iter_recurse(&_iter, &_tmp7_);
    for (; dbus_message_iter_get_arg_type(&_tmp7_); _tmp6__length1++) {
        const char* _tmp8_;
        if (_tmp6__size == _tmp6__length) {
            _tmp6__size = 2 * _tmp6__size;
            _tmp6_ = g_renew(char*, _tmp6_, _tmp6__size + 1);
        }
        dbus_message_iter_get_basic(&_tmp7_, &_tmp8_);
        dbus_message_iter_next(&_tmp7_);
        _tmp6_[_tmp6__length++] = g_strdup(_tmp8_);
    }
    _result_length1 = _tmp6__length1;
    _tmp6_[_tmp6__length] = NULL;
    dbus_message_iter_next(&_iter);
    _result = _tmp6_;
    *result_length1 = _result_length1;
    dbus_message_unref(reply);
    return _result;
}


static char** dock_manager_dbus_interface_dbus_proxy_get_items_by_name(DockManagerDBusInterface* self, const gchar* name, int* result_length1, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter _iter;
    char** _result;
    int _result_length1;
    char** _tmp11_;
    int _tmp11__length;
    int _tmp11__size;
    int _tmp11__length1;
    DBusMessageIter _tmp12_;
    if (((DockManagerDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return NULL;
    }
    DBusMessage* message = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "net.launchpad.DockManager", "GetItemsByName");
    dbus_message_iter_init_append(message, &_iter);
    awn::vala_dbus_iter_append_string(&_iter, name);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), message, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(message);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);
        dbus_error_free(&_dbus_error);
        return NULL;
    }
    if (strcmp(dbus_message_get_signature(reply), "ao")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "ao", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return NULL;
    }
    dbus_message_iter_init(reply, &_iter);
    _result_length1 = 0;
    _tmp11_ = g_new(char*, 5);
    _tmp11__length = 0;
    _tmp11__size = 4;
    _tmp11__length1 = 0;
    dbus_message_iter_recurse(&_iter, &_tmp12_);
    for (; dbus_message_iter_get_arg_type(&_tmp12_); _tmp11__length1++) {
        const char* _tmp13_;
        if (_tmp11__size == _tmp11__length) {
            _tmp11__size = 2 * _tmp11__size;
            _tmp11_ = g_renew(char*, _tmp11_, _tmp11__size + 1);
        }
        dbus_message_iter_get_basic(&_tmp12_, &_tmp13_);
        dbus_message_iter_next(&_tmp12_);
        _tmp11_[_tmp11__length++] = g_strdup(_tmp13_);
    }
    _result_length1 = _tmp11__length1;
    _tmp11_[_tmp11__length] = NULL;
    dbus_message_iter_next(&_iter);
    _result = _tmp11_;
    *result_length1 = _result_length1;
    dbus_message_unref(reply);
    return _result;
}


static char** dock_manager_dbus_interface_dbus_proxy_get_items_by_desktop_file(DockManagerDBusInterface* self, const gchar* desktop_file, int* result_length1, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter _iter;
    char** _result;
    char** _tmp16_;
    int _tmp16__length;
    int _tmp16__size;
    DBusMessageIter _tmp17_;
    if (((DockManagerDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return NULL;
    }
    DBusMessage* message = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "net.launchpad.DockManager", "GetItemsByDesktopFile");
    dbus_message_iter_init_append(message, &_iter);
    awn::vala_dbus_iter_append_string(&_iter, desktop_file);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), message, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(message);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);
        dbus_error_free(&_dbus_error);
        return NULL;
    }
    if (strcmp(dbus_message_get_signature(reply), "ao")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "ao", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return NULL;
    }
    dbus_message_iter_init(reply, &_iter);
    _tmp16_ = g_new(char*, 5);
    _tmp16__length = 0;
    _tmp16__size = 4;
    int _result_length1 = 0;
    dbus_message_iter_recurse(&_iter, &_tmp17_);
    for (; dbus_message_iter_get_arg_type(&_tmp17_); _result_length1++) {
        const char* _tmp18_;
        if (_tmp16__size == _tmp16__length) {
            _tmp16__size = 2 * _tmp16__size;
            _tmp16_ = g_renew(char*, _tmp16_, _tmp16__size + 1);
        }
        dbus_message_iter_get_basic(&_tmp17_, &_tmp18_);
        dbus_message_iter_next(&_tmp17_);
        _tmp16_[_tmp16__length++] = g_strdup(_tmp18_);
    }
    _tmp16_[_tmp16__length] = NULL;
    dbus_message_iter_next(&_iter);
    _result = _tmp16_;
    *result_length1 = _result_length1;
    dbus_message_unref(reply);
    return _result;
}


static char** dock_manager_dbus_interface_dbus_proxy_get_items_by_pid(DockManagerDBusInterface* self, gint pid, int* result_length1, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter _iter;
    char** _result;
    int _result_length1;
    char** _tmp21_;
    int _tmp21__length;
    int _tmp21__size;
    int _tmp21__length1;
    DBusMessageIter _tmp22_;
    if (((DockManagerDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return NULL;
    }
    DBusMessage* message = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "net.launchpad.DockManager", "GetItemsByPid");
    dbus_message_iter_init_append(message, &_iter);
    awn::vala_dbus_iter_append_int32(&_iter, pid);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), message, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(message);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);
        dbus_error_free(&_dbus_error);
        return NULL;
    }
    if (strcmp(dbus_message_get_signature(reply), "ao")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "ao", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return NULL;
    }
    dbus_message_iter_init(reply, &_iter);
    _result_length1 = 0;
    _tmp21_ = g_new(char*, 5);
    _tmp21__length = 0;
    _tmp21__size = 4;
    _tmp21__length1 = 0;
    dbus_message_iter_recurse(&_iter, &_tmp22_);
    for (; dbus_message_iter_get_arg_type(&_tmp22_); _tmp21__length1++) {
        const char* _tmp23_;
        if (_tmp21__size == _tmp21__length) {
            _tmp21__size = 2 * _tmp21__size;
            _tmp21_ = g_renew(char*, _tmp21_, _tmp21__size + 1);
        }
        dbus_message_iter_get_basic(&_tmp22_, &_tmp23_);
        dbus_message_iter_next(&_tmp22_);
        _tmp21_[_tmp21__length++] = g_strdup(_tmp23_);
    }
    _result_length1 = _tmp21__length1;
    _tmp21_[_tmp21__length] = NULL;
    dbus_message_iter_next(&_iter);
    _result = _tmp21_;
    *result_length1 = _result_length1;
    dbus_message_unref(reply);
    return _result;
}


static char* dock_manager_dbus_interface_dbus_proxy_get_item_by_xid(DockManagerDBusInterface* self, gint64 xid, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter _iter;
    char* _result;
    const char* _tmp26_;
    if (((DockManagerDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return NULL;
    }
    DBusMessage* message = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "net.launchpad.DockManager", "GetItemByXid");
    dbus_message_iter_init_append(message, &_iter);
    awn::vala_dbus_iter_append_int64(&_iter, xid);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), message, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(message);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);
        dbus_error_free(&_dbus_error);
        return NULL;
    }
    if (strcmp(dbus_message_get_signature(reply), "o")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "o", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return NULL;
    }
    dbus_message_iter_init(reply, &_iter);
    dbus_message_iter_get_basic(&_iter, &_tmp26_);
    dbus_message_iter_next(&_iter);
    _result = g_strdup(_tmp26_);
    dbus_message_unref(reply);
    return _result;
}


static void dock_manager_dbus_interface_dbus_proxy_awn_set_visibility(DockManagerDBusInterface* self, const gchar* win_name, gboolean visible, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter _iter;
    if (((DockManagerDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return;
    }
    DBusMessage* message = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "net.launchpad.DockManager", "AwnSetVisibility");
    dbus_message_iter_init_append(message, &_iter);
    awn::vala_dbus_iter_append_string(&_iter, win_name);
    awn::vala_dbus_iter_append_bool(&_iter, visible);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), message, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(message);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);
        dbus_error_free(&_dbus_error);
        return;
    }
    if (strcmp(dbus_message_get_signature(reply), "")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return;
    }
    dbus_message_iter_init(reply, &_iter);
    dbus_message_unref(reply);
}


static char* dock_manager_dbus_interface_dbus_proxy_awn_register_proxy_item(DockManagerDBusInterface* self, const gchar* desktop_file, const gchar* uri, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter _iter;
    char* _result;
    const char* _tmp33_;
    if (((DockManagerDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return NULL;
    }
    DBusMessage* message = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "net.launchpad.DockManager", "AwnRegisterProxyItem");
    dbus_message_iter_init_append(message, &_iter);
    awn::vala_dbus_iter_append_string(&_iter, desktop_file);
    awn::vala_dbus_iter_append_string(&_iter, uri);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), message, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(message);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);
        dbus_error_free(&_dbus_error);
        return NULL;
    }
    if (strcmp(dbus_message_get_signature(reply), "o")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "o", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return NULL;
    }
    dbus_message_iter_init(reply, &_iter);
    dbus_message_iter_get_basic(&_iter, &_tmp33_);
    dbus_message_iter_next(&_iter);
    _result = g_strdup(_tmp33_);
    dbus_message_unref(reply);
    return _result;
}


static void dock_manager_dbus_interface_dbus_proxy_dock_manager_dbus_interface__interface_init(DockManagerDBusInterfaceIface* iface)
{
    iface->get_capabilities = dock_manager_dbus_interface_dbus_proxy_get_capabilities;
    iface->get_items = dock_manager_dbus_interface_dbus_proxy_get_items;
    iface->get_items_by_name = dock_manager_dbus_interface_dbus_proxy_get_items_by_name;
    iface->get_items_by_desktop_file = dock_manager_dbus_interface_dbus_proxy_get_items_by_desktop_file;
    iface->get_items_by_pid = dock_manager_dbus_interface_dbus_proxy_get_items_by_pid;
    iface->get_item_by_xid = dock_manager_dbus_interface_dbus_proxy_get_item_by_xid;
    iface->awn_set_visibility = dock_manager_dbus_interface_dbus_proxy_awn_set_visibility;
    iface->awn_register_proxy_item = dock_manager_dbus_interface_dbus_proxy_awn_register_proxy_item;
}


static void _vala_dock_manager_dbus_interface_dbus_proxy_get_property(GObject* object, guint property_id, GValue* value, GParamSpec* pspec)
{
}


static void _vala_dock_manager_dbus_interface_dbus_proxy_set_property(GObject* object, guint property_id, const GValue* value, GParamSpec* pspec)
{
}


gint dock_item_dbus_interface_add_menu_item(DockItemDBusInterface* self, GHashTable* menu_hints, GError** error)
{
    return DOCK_ITEM_DBUS_INTERFACE_GET_INTERFACE(self)->add_menu_item(self, menu_hints, error);
}


void dock_item_dbus_interface_remove_menu_item(DockItemDBusInterface* self, gint id, GError** error)
{
    DOCK_ITEM_DBUS_INTERFACE_GET_INTERFACE(self)->remove_menu_item(self, id, error);
}


void dock_item_dbus_interface_update_dock_item(DockItemDBusInterface* self, GHashTable* hints, GError** error)
{
    DOCK_ITEM_DBUS_INTERFACE_GET_INTERFACE(self)->update_dock_item(self, hints, error);
}


gchar* dock_item_dbus_interface_get_desktop_file(DockItemDBusInterface* self)
{
    return DOCK_ITEM_DBUS_INTERFACE_GET_INTERFACE(self)->get_desktop_file(self);
}


gchar* dock_item_dbus_interface_get_uri(DockItemDBusInterface* self)
{
    return DOCK_ITEM_DBUS_INTERFACE_GET_INTERFACE(self)->get_uri(self);
}


static void dock_item_dbus_interface_base_init(DockItemDBusInterfaceIface* iface)
{
    static gboolean initialized = FALSE;
    if (!initialized) {
        initialized = TRUE;
        g_signal_new("menu_item_activated", TYPE_DOCK_ITEM_DBUS_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
    }
}


void _dock_item_dbus_interface_dbus_unregister(DBusConnection* connection, void* _user_data_)
{
}


static DBusHandlerResult _dbus_dock_item_dbus_interface_introspect(DockItemDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    char** children;
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    std::string xml_data{"<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n"};
    xml_data += "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"net.launchpad.DockItem\">\n  <method name=\"AddMenuItem\">\n    <arg name=\"menu_hints\" type=\"a{sv}\" direction=\"in\"/>\n    <arg name=\"result\" type=\"i\" direction=\"out\"/>\n  </method>\n  <method name=\"RemoveMenuItem\">\n    <arg name=\"id\" type=\"i\" direction=\"in\"/>\n  </method>\n  <method name=\"UpdateDockItem\">\n    <arg name=\"hints\" type=\"a{sv}\" direction=\"in\"/>\n  </method>\n  <property name=\"DesktopFile\" type=\"s\" access=\"read\"/>\n  <property name=\"Uri\" type=\"s\" access=\"read\"/>\n  <signal name=\"MenuItemActivated\">\n    <arg name=\"id\" type=\"i\"/>\n  </signal>\n</interface>\n";
    dbus_connection_list_registered(connection, g_object_get_data((GObject*) self, "dbus_object_path"), &children);
    for (int i = 0; children[i]; i++) {
        xml_data = xml_data + "<node name=\"" + children[i] + "\"/>\n";
    }
    dbus_free_string_array(children);
    xml_data += "</node>\n";
    awn::vala_dbus_iter_append_string(&iter, xml_data.c_str());
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_dock_item_dbus_interface_property_get(DockItemDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter, reply_iter, subiter;
    char* interface_name;
    const char* _tmp0_;
    char* property_name;
    const char* _tmp1_;
    if (strcmp(dbus_message_get_signature(message), "ss")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &reply_iter);
    dbus_message_iter_get_basic(&iter, &_tmp0_);
    dbus_message_iter_next(&iter);
    interface_name = g_strdup(_tmp0_);
    dbus_message_iter_get_basic(&iter, &_tmp1_);
    dbus_message_iter_next(&iter);
    property_name = g_strdup(_tmp1_);
    if ((strcmp(interface_name, "net.launchpad.DockItem") == 0) && (strcmp(property_name, "DesktopFile") == 0)) {
        dbus_message_iter_open_container(&reply_iter, DBUS_TYPE_VARIANT, "s", &subiter);
        char* result = dock_item_dbus_interface_get_desktop_file(self);
        awn::vala_dbus_iter_append_string(&subiter, result);
        _g_free0(result);
        dbus_message_iter_close_container(&reply_iter, &subiter);
    } else if ((strcmp(interface_name, "net.launchpad.DockItem") == 0) && (strcmp(property_name, "Uri") == 0)) {
        dbus_message_iter_open_container(&reply_iter, DBUS_TYPE_VARIANT, "s", &subiter);
        char* result = dock_item_dbus_interface_get_uri(self);
        awn::vala_dbus_iter_append_string(&subiter, result);
        _g_free0(result);
        dbus_message_iter_close_container(&reply_iter, &subiter);
    } else {
        dbus_message_unref(reply);
        reply = NULL;
    }
    g_free(interface_name);
    g_free(property_name);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_dock_item_dbus_interface_property_get_all(DockItemDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter, reply_iter, subiter, entry_iter, value_iter;
    char* interface_name;
    const char* _tmp4_;
    if (strcmp(dbus_message_get_signature(message), "s")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &reply_iter);
    dbus_message_iter_get_basic(&iter, &_tmp4_);
    dbus_message_iter_next(&iter);
    interface_name = g_strdup(_tmp4_);
    if (strcmp(interface_name, "net.launchpad.DockItem") == 0) {
        dbus_message_iter_open_container(&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
        {
            gchar* result;
            const char* _tmp5_;
            dbus_message_iter_open_container(&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
            awn::vala_dbus_iter_append_string(&entry_iter, "DesktopFile");
            dbus_message_iter_open_container(&entry_iter, DBUS_TYPE_VARIANT, "s", &value_iter);
            result = dock_item_dbus_interface_get_desktop_file(self);
            _tmp5_ = result;
            awn::vala_dbus_iter_append_string(&value_iter, _tmp5_);
            _g_free0(result);
            dbus_message_iter_close_container(&entry_iter, &value_iter);
            dbus_message_iter_close_container(&subiter, &entry_iter);
        }
        {
            gchar* result;
            dbus_message_iter_open_container(&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
            awn::vala_dbus_iter_append_string(&entry_iter, "Uri");
            dbus_message_iter_open_container(&entry_iter, DBUS_TYPE_VARIANT, "s", &value_iter);
            awn::vala_dbus_iter_append_string(&value_iter,
                                              dock_item_dbus_interface_get_uri(self));
            _g_free0(result);
            dbus_message_iter_close_container(&entry_iter, &value_iter);
            dbus_message_iter_close_container(&subiter, &entry_iter);
        }
        dbus_message_iter_close_container(&reply_iter, &subiter);
    } else {
        dbus_message_unref(reply);
        reply = NULL;
    }
    g_free(interface_name);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_dock_item_dbus_interface_add_menu_item(DockItemDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    GError* error;
    GHashTable* menu_hints = NULL;
    GHashTable* _tmp7_;
    DBusMessageIter _tmp8_;
    DBusMessageIter _tmp9_;
    gint result;
    error = NULL;
    if (strcmp(dbus_message_get_signature(message), "a{sv}")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    _tmp7_ = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
    dbus_message_iter_recurse(&iter, &_tmp8_);
    while (dbus_message_iter_get_arg_type(&_tmp8_)) {
        gchar* _key;
        GValue* _value;
        const char* _tmp10_;
        dbus_message_iter_recurse(&_tmp8_, &_tmp9_);
        dbus_message_iter_get_basic(&_tmp9_, &_tmp10_);
        dbus_message_iter_next(&_tmp9_);
        _key = g_strdup(_tmp10_);

        GValue _tmp11_ = {0};
        awn::vala_dbus_get_gvalue(&_tmp9_, &_tmp11_);
        dbus_message_iter_next(&_tmp9_);
        _value = g_memdup(&_tmp11_, sizeof(GValue));
        g_hash_table_insert(_tmp7_, _key, _value);
        dbus_message_iter_next(&_tmp8_);
    }
    dbus_message_iter_next(&iter);
    menu_hints = _tmp7_;
    result = dock_item_dbus_interface_add_menu_item(self, menu_hints, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    _g_hash_table_unref0(menu_hints);
    awn::vala_dbus_iter_append_int32(&iter, result);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_dock_item_dbus_interface_remove_menu_item(DockItemDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    GError* error;
    gint id = 0;
    dbus_int32_t _tmp29_;
    error = NULL;
    if (strcmp(dbus_message_get_signature(message), "i")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    dbus_message_iter_get_basic(&iter, &_tmp29_);
    dbus_message_iter_next(&iter);
    id = _tmp29_;
    dock_item_dbus_interface_remove_menu_item(self, id, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_dock_item_dbus_interface_update_dock_item(DockItemDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    GError* error;
    GHashTable* hints = NULL;
    GHashTable* _tmp30_;
    DBusMessageIter _tmp31_;
    DBusMessageIter _tmp32_;
    error = NULL;
    if (strcmp(dbus_message_get_signature(message), "a{sv}")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    _tmp30_ = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
    dbus_message_iter_recurse(&iter, &_tmp31_);
    while (dbus_message_iter_get_arg_type(&_tmp31_)) {
        gchar* _key;
        GValue* _value;
        const char* _tmp33_;
        dbus_message_iter_recurse(&_tmp31_, &_tmp32_);
        dbus_message_iter_get_basic(&_tmp32_, &_tmp33_);
        dbus_message_iter_next(&_tmp32_);
        _key = g_strdup(_tmp33_);

        GValue _tmp34_ = {0};
        awn::vala_dbus_get_gvalue(&_tmp32_, &_tmp34_);
        dbus_message_iter_next(&_tmp32_);

        _value = g_memdup(&_tmp34_, sizeof(GValue));
        g_hash_table_insert(_tmp30_, _key, _value);
        dbus_message_iter_next(&_tmp31_);
    }
    dbus_message_iter_next(&iter);
    hints = _tmp30_;
    dock_item_dbus_interface_update_dock_item(self, hints, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    _g_hash_table_unref0(hints);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


DBusHandlerResult dock_item_dbus_interface_dbus_message(DBusConnection* connection, DBusMessage* message, void* object)
{
    DBusHandlerResult result;
    result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    if (dbus_message_is_method_call(message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
        result = _dbus_dock_item_dbus_interface_introspect(object, connection, message);
    } else if (dbus_message_is_method_call(message, "org.freedesktop.DBus.Properties", "Get")) {
        result = _dbus_dock_item_dbus_interface_property_get(object, connection, message);
    } else if (dbus_message_is_method_call(message, "org.freedesktop.DBus.Properties", "GetAll")) {
        result = _dbus_dock_item_dbus_interface_property_get_all(object, connection, message);
    } else if (dbus_message_is_method_call(message, "net.launchpad.DockItem", "AddMenuItem")) {
        result = _dbus_dock_item_dbus_interface_add_menu_item(object, connection, message);
    } else if (dbus_message_is_method_call(message, "net.launchpad.DockItem", "RemoveMenuItem")) {
        result = _dbus_dock_item_dbus_interface_remove_menu_item(object, connection, message);
    } else if (dbus_message_is_method_call(message, "net.launchpad.DockItem", "UpdateDockItem")) {
        result = _dbus_dock_item_dbus_interface_update_dock_item(object, connection, message);
    }
    if (result == DBUS_HANDLER_RESULT_HANDLED) {
        return result;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static void _dbus_dock_item_dbus_interface_menu_item_activated(GObject* _sender, gint id, DBusConnection* _connection)
{
    DBusMessageIter _iter;
    const char* path = g_object_get_data(_sender, "dbus_object_path");
    DBusMessage* message = dbus_message_new_signal(path, "net.launchpad.DockItem", "MenuItemActivated");
    dbus_message_iter_init_append(message, &_iter);
    awn::vala_dbus_iter_append_int32(&_iter, id);
    dbus_connection_send(_connection, message, NULL);
    dbus_message_unref(message);
}


void dock_item_dbus_interface_dbus_register_object(DBusConnection* connection, const char* path, void* object)
{
    if (!g_object_get_data(object, "dbus_object_path")) {
        g_object_set_data(object, "dbus_object_path", g_strdup(path));
        dbus_connection_register_object_path(connection, path, &_dock_item_dbus_interface_dbus_path_vtable, object);
        g_object_weak_ref(object, _vala_dbus_unregister_object, connection);
    }
    g_signal_connect(object, "menu-item-activated", (GCallback) _dbus_dock_item_dbus_interface_menu_item_activated, connection);
}


GType dock_item_dbus_interface_get_type(void)
{
    static volatile gsize dock_item_dbus_interface_type_id__volatile = 0;
    if (g_once_init_enter(&dock_item_dbus_interface_type_id__volatile)) {
        static const GTypeInfo g_define_type_info = { sizeof(DockItemDBusInterfaceIface), (GBaseInitFunc) dock_item_dbus_interface_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
        GType dock_item_dbus_interface_type_id;
        dock_item_dbus_interface_type_id = g_type_register_static(G_TYPE_INTERFACE, "DockItemDBusInterface", &g_define_type_info, 0);
        g_type_interface_add_prerequisite(dock_item_dbus_interface_type_id, G_TYPE_OBJECT);
        g_type_set_qdata(dock_item_dbus_interface_type_id, g_quark_from_string("ValaDBusInterfaceProxyType"), &dock_item_dbus_interface_dbus_proxy_get_type);
        g_type_set_qdata(dock_item_dbus_interface_type_id, g_quark_from_static_string("DBusObjectVTable"), (void*)(&_dock_item_dbus_interface_dbus_vtable));
        g_once_init_leave(&dock_item_dbus_interface_type_id__volatile, dock_item_dbus_interface_type_id);
    }
    return dock_item_dbus_interface_type_id__volatile;
}

extern "C" {
    G_DEFINE_TYPE_EXTENDED(DockItemDBusInterfaceDBusProxy, dock_item_dbus_interface_dbus_proxy, DBUS_TYPE_G_PROXY, 0, G_IMPLEMENT_INTERFACE(TYPE_DOCK_ITEM_DBUS_INTERFACE, dock_item_dbus_interface_dbus_proxy_dock_item_dbus_interface__interface_init));
}

DockItemDBusInterface* dock_item_dbus_interface_dbus_proxy_new(DBusGConnection* connection, const char* name, const char* path)
{
    DockItemDBusInterface* self;
    self = g_object_new(dock_item_dbus_interface_dbus_proxy_get_type(), "connection", connection, "name", name, "path", path, "interface", "net.launchpad.DockItem", NULL);
    return self;
}


static GObject* dock_item_dbus_interface_dbus_proxy_construct(GType gtype, guint n_properties, GObjectConstructParam* properties)
{
    GObject* self;
    DBusGConnection* connection;
    char* path;
    char* filter;
    self = G_OBJECT_CLASS(dock_item_dbus_interface_dbus_proxy_parent_class)->constructor(gtype, n_properties, properties);
    g_object_get(self, "connection", &connection, NULL);
    g_object_get(self, "path", &path, NULL);
    dbus_connection_add_filter(dbus_g_connection_get_connection(connection), dock_item_dbus_interface_dbus_proxy_filter, self, NULL);
    filter = g_strdup_printf("type='signal',path='%s',interface='net.launchpad.DockItem'", path);
    dbus_bus_add_match(dbus_g_connection_get_connection(connection), filter, NULL);
    dbus_g_connection_unref(connection);
    g_free(path);
    g_free(filter);
    return self;
}


static void _dbus_handle_dock_item_dbus_interface_menu_item_activated(DockItemDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    gint id = 0;
    dbus_int32_t _tmp35_;
    if (strcmp(dbus_message_get_signature(message), "i")) {
        return;
    }
    dbus_message_iter_init(message, &iter);
    dbus_message_iter_get_basic(&iter, &_tmp35_);
    dbus_message_iter_next(&iter);
    id = _tmp35_;
    g_signal_emit_by_name(self, "menu-item-activated", id);
}


DBusHandlerResult dock_item_dbus_interface_dbus_proxy_filter(DBusConnection* connection, DBusMessage* message, void* user_data)
{
    if (dbus_message_has_path(message, dbus_g_proxy_get_path(user_data))) {
        if (dbus_message_is_signal(message, "net.launchpad.DockItem", "MenuItemActivated")) {
            _dbus_handle_dock_item_dbus_interface_menu_item_activated(user_data, connection, message);
        }
    }
    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}


static void dock_item_dbus_interface_dbus_proxy_dispose(GObject* self)
{
    DBusGConnection* connection;
    if (((DockItemDBusInterfaceDBusProxy*) self)->disposed) {
        return;
    }
    ((DockItemDBusInterfaceDBusProxy*) self)->disposed = TRUE;
    g_object_get(self, "connection", &connection, NULL);
    dbus_connection_remove_filter(dbus_g_connection_get_connection(connection), dock_item_dbus_interface_dbus_proxy_filter, self);
    G_OBJECT_CLASS(dock_item_dbus_interface_dbus_proxy_parent_class)->dispose(self);
}


static void dock_item_dbus_interface_dbus_proxy_class_init(DockItemDBusInterfaceDBusProxyClass* klass)
{
    G_OBJECT_CLASS(klass)->constructor = dock_item_dbus_interface_dbus_proxy_construct;
    G_OBJECT_CLASS(klass)->dispose = dock_item_dbus_interface_dbus_proxy_dispose;
    G_OBJECT_CLASS(klass)->get_property = _vala_dock_item_dbus_interface_dbus_proxy_get_property;
    G_OBJECT_CLASS(klass)->set_property = _vala_dock_item_dbus_interface_dbus_proxy_set_property;
}


static void dock_item_dbus_interface_dbus_proxy_init(DockItemDBusInterfaceDBusProxy* self)
{
}


static gint dock_item_dbus_interface_dbus_proxy_add_menu_item(DockItemDBusInterface* self, GHashTable* menu_hints, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter _iter;
    DBusMessageIter _tmp36_;
    GHashTableIter _tmp38_;
    gpointer _tmp39_, _tmp40_;
    gint _result;
    dbus_int32_t _tmp55_;
    if (((DockItemDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return 0;
    }
    DBusMessage* message = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "net.launchpad.DockItem", "AddMenuItem");
    dbus_message_iter_init_append(message, &_iter);
    dbus_message_iter_open_container(&_iter, DBUS_TYPE_ARRAY, "{sv}", &_tmp36_);
    g_hash_table_iter_init(&_tmp38_, menu_hints);
    while (g_hash_table_iter_next(&_tmp38_, &_tmp39_, &_tmp40_)) {
        DBusMessageIter it;
        dbus_message_iter_open_container(&_tmp36_, DBUS_TYPE_DICT_ENTRY, NULL, &it);
        awn::vala_dbus_append_gvalue(&it, (char*) _tmp39_, (GValue*) _tmp40_);
        dbus_message_iter_close_container(&_tmp36_, &it);
    }
    dbus_message_iter_close_container(&_iter, &_tmp36_);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), message, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(message);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);
        dbus_error_free(&_dbus_error);
        return 0;
    }
    if (strcmp(dbus_message_get_signature(reply), "i")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "i", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return 0;
    }
    dbus_message_iter_init(reply, &_iter);
    dbus_message_iter_get_basic(&_iter, &_tmp55_);
    dbus_message_iter_next(&_iter);
    _result = _tmp55_;
    dbus_message_unref(reply);
    return _result;
}


static void dock_item_dbus_interface_dbus_proxy_remove_menu_item(DockItemDBusInterface* self, gint id, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessage* message, *reply;
    DBusMessageIter _iter;
    if (((DockItemDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return;
    }
    message = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "net.launchpad.DockItem", "RemoveMenuItem");
    dbus_message_iter_init_append(message, &_iter);
    awn::vala_dbus_iter_append_int32(&_iter, id);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), message, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(message);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);
        dbus_error_free(&_dbus_error);
        return;
    }
    if (strcmp(dbus_message_get_signature(reply), "")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return;
    }
    dbus_message_iter_init(reply, &_iter);
    dbus_message_unref(reply);
}


static void dock_item_dbus_interface_dbus_proxy_update_dock_item(DockItemDBusInterface* self, GHashTable* hints, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter _iter;
    DBusMessageIter _tmp59_;
    GHashTableIter _tmp61_;
    gpointer _tmp62_, _tmp63_;
    if (((DockItemDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return;
    }
    DBusMessage* message = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "net.launchpad.DockItem", "UpdateDockItem");
    dbus_message_iter_init_append(message, &_iter);
    dbus_message_iter_open_container(&_iter, DBUS_TYPE_ARRAY, "{sv}", &_tmp59_);
    g_hash_table_iter_init(&_tmp61_, hints);
    while (g_hash_table_iter_next(&_tmp61_, &_tmp62_, &_tmp63_)) {
        DBusMessageIter it;
        dbus_message_iter_open_container(&_tmp59_, DBUS_TYPE_DICT_ENTRY, NULL, &it);
        awn::vala_dbus_append_gvalue(&it, (char*) _tmp62_, (GValue*) _tmp63_);
        dbus_message_iter_close_container(&_tmp59_, &it);
    }
    dbus_message_iter_close_container(&_iter, &_tmp59_);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), message, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(message);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);
        dbus_error_free(&_dbus_error);
        return;
    }
    if (strcmp(dbus_message_get_signature(reply), "")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return;
    }
    dbus_message_iter_init(reply, &_iter);
    dbus_message_unref(reply);
}


static gchar* dock_item_dbus_interface_dbus_proxy_get_desktop_file(DockItemDBusInterface* self)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter _iter, _subiter;
    gchar* _result;
    const char* _tmp81_;
    if (((DockItemDBusInterfaceDBusProxy*) self)->disposed) {
        return NULL;
    }
    DBusMessage* message = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
    dbus_message_iter_init_append(message, &_iter);
    awn::vala_dbus_iter_append_string(&_iter, "net.launchpad.DockItem");
    awn::vala_dbus_iter_append_string(&_iter, "DesktopFile");
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), message, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(message);
    if (dbus_error_is_set(&_dbus_error)) {
        g_critical("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
        dbus_error_free(&_dbus_error);
        return NULL;
    }
    if (strcmp(dbus_message_get_signature(reply), "v")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "v", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return NULL;
    }
    dbus_message_iter_init(reply, &_iter);
    dbus_message_iter_recurse(&_iter, &_subiter);
    if (strcmp(dbus_message_iter_get_signature(&_subiter), "s")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "s", dbus_message_iter_get_signature(&_subiter));
        dbus_message_unref(reply);
        return NULL;
    }
    dbus_message_iter_get_basic(&_subiter, &_tmp81_);
    dbus_message_iter_next(&_subiter);
    _result = g_strdup(_tmp81_);
    dbus_message_unref(reply);
    return _result;
}


static gchar* dock_item_dbus_interface_dbus_proxy_get_uri(DockItemDBusInterface* self)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter _iter, _subiter;
    gchar* _result;
    const char* _tmp84_;
    if (((DockItemDBusInterfaceDBusProxy*) self)->disposed) {
        return NULL;
    }
    DBusMessage* message = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
    dbus_message_iter_init_append(message, &_iter);
    awn::vala_dbus_iter_append_string(&_iter, "net.launchpad.DockItem");
    awn::vala_dbus_iter_append_string(&_iter, "Uri");
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), message, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(message);
    if (dbus_error_is_set(&_dbus_error)) {
        g_critical("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
        dbus_error_free(&_dbus_error);
        return NULL;
    }
    if (strcmp(dbus_message_get_signature(reply), "v")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "v", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return NULL;
    }
    dbus_message_iter_init(reply, &_iter);
    dbus_message_iter_recurse(&_iter, &_subiter);
    if (strcmp(dbus_message_iter_get_signature(&_subiter), "s")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "s", dbus_message_iter_get_signature(&_subiter));
        dbus_message_unref(reply);
        return NULL;
    }
    dbus_message_iter_get_basic(&_subiter, &_tmp84_);
    dbus_message_iter_next(&_subiter);
    _result = g_strdup(_tmp84_);
    dbus_message_unref(reply);
    return _result;
}


static void dock_item_dbus_interface_dbus_proxy_dock_item_dbus_interface__interface_init(DockItemDBusInterfaceIface* iface)
{
    iface->add_menu_item = dock_item_dbus_interface_dbus_proxy_add_menu_item;
    iface->remove_menu_item = dock_item_dbus_interface_dbus_proxy_remove_menu_item;
    iface->update_dock_item = dock_item_dbus_interface_dbus_proxy_update_dock_item;
    iface->get_desktop_file = dock_item_dbus_interface_dbus_proxy_get_desktop_file;
    iface->get_uri = dock_item_dbus_interface_dbus_proxy_get_uri;
}


static void _vala_dock_item_dbus_interface_dbus_proxy_get_property(GObject* object, guint property_id, GValue* value, GParamSpec* pspec)
{
}


static void _vala_dock_item_dbus_interface_dbus_proxy_set_property(GObject* object, guint property_id, const GValue* value, GParamSpec* pspec)
{
}


TaskManagerDispatcher* task_manager_dispatcher_construct(GType object_type, TaskManager* manager)
{
    DBusGConnection* _tmp0_ = NULL;
    DBusGConnection* conn;
    gchar* _tmp1_;
    gchar* obj_path;
    GError* _inner_error_ = NULL;
    g_return_val_if_fail(manager != NULL, NULL);

    TaskManagerDispatcher* self = (TaskManagerDispatcher*) g_object_new(object_type, "manager", manager, NULL);
    _tmp0_ = dbus_g_bus_get(DBUS_BUS_SESSION, &_inner_error_);
    conn = _tmp0_;
    if (_inner_error_ != NULL) {
        g_critical("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string(_inner_error_->domain), _inner_error_->code);
        g_clear_error(&_inner_error_);
        return NULL;
    }
    _tmp1_ = g_strdup("/net/launchpad/DockManager");
    obj_path = _tmp1_;
    _vala_dbus_register_object(dbus_g_connection_get_connection(conn), obj_path, (GObject*) self);
    _g_free0(obj_path);
    _dbus_g_connection_unref0(conn);
    return self;
}


TaskManagerDispatcher* task_manager_dispatcher_new(TaskManager* manager)
{
    return task_manager_dispatcher_construct(TYPE_TASK_MANAGER_DISPATCHER, manager);
}


static char** task_manager_dispatcher_list_to_object_path_array(GSList* list, int* result_length1)
{
    guint _tmp0_;
    _tmp0_ = g_slist_length(list);
    char** result = g_new0(char*, _tmp0_ + 1);
    int _result__length1 = _tmp0_;
    int i = 0;
    {
        GSList* icon_collection = list;
        for (GSList* icon_it = icon_collection; icon_it != NULL; icon_it = icon_it->next) {
            TaskIcon* icon = (TaskIcon*) icon_it->data;
            GObject* tmp = task_icon_get_dbus_dispatcher(icon);
            TaskIconDispatcher* dispatcher = IS_TASK_ICON_DISPATCHER(tmp) ? ((TaskIconDispatcher*) tmp) : NULL;
            const char* _tmp5_ = task_icon_dispatcher_get_object_path(dispatcher);
            _g_free0(result[i]);
            result[i] = g_strdup(_tmp5_);
            i++;
        }
    }
    if (result_length1) {
        *result_length1 = _result__length1;
    }
    return result;
}


static gchar** task_manager_dispatcher_real_get_capabilities(DockManagerDBusInterface* base, int* result_length1, GError** error)
{
    char** res = g_new0(gchar*, 9 + 1);
    res[0] = g_strdup("dock-item-badge");
    res[1] = g_strdup("dock-item-message");
    res[2] = g_strdup("dock-item-progress");
    res[3] = g_strdup("dock-item-icon-file");
    res[4] = g_strdup("menu-item-container-title");
    res[5] = g_strdup("menu-item-with-label");
    res[6] = g_strdup("menu-item-icon-name");
    res[7] = g_strdup("menu-item-icon-file");
    res[8] = g_strdup("x-awn-set-visibility");
    if (result_length1) {
        *result_length1 = 9;
    }
    return res;
}


static char** task_manager_dispatcher_real_get_items(DockManagerDBusInterface* base, int* result_length1, GError** error)
{
    TaskManagerDispatcher* self = (TaskManagerDispatcher*) base;
    GSList* _tmp0_ = task_manager_get_icons(self->priv->_manager);
    int rlen;
    char** result = task_manager_dispatcher_list_to_object_path_array(_tmp0_, &rlen);
    if (result_length1) {
        *result_length1 = rlen;
    }
    return result;
}


static char** task_manager_dispatcher_real_get_items_by_name(DockManagerDBusInterface* base, const gchar* name, int* result_length1, GError** error)
{
    TaskManagerDispatcher* self = (TaskManagerDispatcher*) base;
    GSList* matches = nullptr;
    g_return_val_if_fail(name != NULL, NULL);
    GSList* icons = task_manager_get_icons(self->priv->_manager);
    {
        GSList* icon_collection;
        GSList* icon_it;
        icon_collection = icons;
        for (icon_it = icon_collection; icon_it != NULL; icon_it = icon_it->next) {
            TaskIcon* icon;
            icon = (TaskIcon*) icon_it->data;
            {
                GSList* _tmp1_ = NULL;
                _tmp1_ = task_icon_get_items(icon);
                {
                    GSList* item_collection;
                    GSList* item_it;
                    item_collection = _tmp1_;
                    for (item_it = item_collection; item_it != NULL; item_it = item_it->next) {
                        TaskItem* item;
                        item = (TaskItem*) item_it->data;
                        {
                            TaskItem* _tmp2_;
                            TaskWindow* window;
                            _tmp2_ = item;
                            window = TASK_IS_WINDOW(_tmp2_) ? ((TaskWindow*) _tmp2_) : NULL;
                            if (window != NULL) {
                                gboolean _tmp3_;
                                _tmp3_ = task_window_matches_wmclass(window, name);
                                if (_tmp3_) {
                                    matches = g_slist_append(matches, icon);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    int res_len;
    char** result = task_manager_dispatcher_list_to_object_path_array(matches, &res_len);
    if (result_length1) {
        *result_length1 = res_len;
    }
    _g_slist_free0(matches);
    return result;
}


static char** task_manager_dispatcher_real_get_items_by_desktop_file(DockManagerDBusInterface* base, const gchar* desktop_file, int* result_length1, GError** error)
{
    TaskManagerDispatcher* self = (TaskManagerDispatcher*) base;
    char** result = NULL;
    GSList* _tmp0_ = NULL;
    GSList* icons;
    GSList* matches;
    gint _tmp5_;
    char** _tmp6_ = NULL;
    char** _tmp7_;
    g_return_val_if_fail(desktop_file != NULL, NULL);
    _tmp0_ = task_manager_get_icons(self->priv->_manager);
    icons = _tmp0_;
    matches = NULL;
    {
        GSList* icon_collection;
        GSList* icon_it;
        icon_collection = icons;
        for (icon_it = icon_collection; icon_it != NULL; icon_it = icon_it->next) {
            TaskIcon* icon;
            icon = (TaskIcon*) icon_it->data;
            {
                TaskItem* _tmp1_ = NULL;
                TaskItem* _tmp2_;
                TaskLauncher* launcher;
                _tmp1_ = task_icon_get_launcher(icon);
                _tmp2_ = _tmp1_;
                launcher = TASK_IS_LAUNCHER(_tmp2_) ? ((TaskLauncher*) _tmp2_) : NULL;
                if (launcher != NULL) {
                    const gchar* _tmp3_ = NULL;
                    gboolean _tmp4_;
                    _tmp3_ = task_launcher_get_desktop_path(launcher);
                    _tmp4_ = g_str_has_suffix(_tmp3_, desktop_file);
                    if (_tmp4_) {
                        matches = g_slist_append(matches, icon);
                    }
                }
            }
        }
    }
    _tmp6_ = task_manager_dispatcher_list_to_object_path_array(matches, &_tmp5_);
    _tmp7_ = _tmp6_;
    if (result_length1) {
        *result_length1 = _tmp5_;
    }
    result = _tmp7_;
    _g_slist_free0(matches);
    return result;
}


static char** task_manager_dispatcher_real_get_items_by_pid(DockManagerDBusInterface* base, gint pid, int* result_length1, GError** error)
{
    TaskManagerDispatcher* self = (TaskManagerDispatcher*) base;
    GSList* matches = nullptr;
    gint _tmp4_;
    GSList* icons = task_manager_get_icons(self->priv->_manager);
    {
        for (GSList* icon_it = icons; icon_it != NULL; icon_it = icon_it->next) {
            TaskIcon* icon;
            icon = (TaskIcon*) icon_it->data;
            {
                GSList* _tmp1_ = NULL;
                _tmp1_ = task_icon_get_items(icon);
                {
                    GSList* item_collection;
                    GSList* item_it;
                    item_collection = _tmp1_;
                    for (item_it = item_collection; item_it != NULL; item_it = item_it->next) {
                        TaskItem* item;
                        item = (TaskItem*) item_it->data;
                        {
                            if (TASK_IS_WINDOW(item)) {
                                TaskItem* _tmp2_;
                                TaskWindow* window;
                                gint _tmp3_;
                                _tmp2_ = item;
                                window = TASK_IS_WINDOW(_tmp2_) ? ((TaskWindow*) _tmp2_) : NULL;
                                _tmp3_ = task_window_get_pid(window);
                                if (_tmp3_ == pid) {
                                    matches = g_slist_append(matches, icon);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    char** result = task_manager_dispatcher_list_to_object_path_array(matches, &_tmp4_);
    if (result_length1) {
        *result_length1 = _tmp4_;
    }
    _g_slist_free0(matches);
    return result;
}


static char* task_manager_dispatcher_real_get_item_by_xid(DockManagerDBusInterface* base, gint64 xid, GError** error)
{
    TaskManagerDispatcher* self = (TaskManagerDispatcher*) base;
    TaskIcon* icon = task_manager_get_icon_by_xid(self->priv->_manager, xid);
    if (icon != NULL) {
        GObject* obj = task_icon_get_dbus_dispatcher(icon);
        TaskIconDispatcher* dispatcher = IS_TASK_ICON_DISPATCHER(obj) ? ((TaskIconDispatcher*) obj) : NULL;
        const gchar* _tmp3_ = task_icon_dispatcher_get_object_path(dispatcher);
        return g_strdup(_tmp3_);
    }
    return nullptr;
}


static void _g_free0_(gpointer var)
{
    var = (g_free(var), NULL);
}


static void _vala_GValue_free(GValue* self)
{
    g_value_unset(self);
    g_free(self);
}


static void __vala_GValue_free0_(gpointer var)
{
    (var == NULL) ? NULL : (var = (_vala_GValue_free(var), NULL));
}


static void task_manager_dispatcher_real_awn_set_visibility(DockManagerDBusInterface* base, const gchar* win_name, gboolean visible, GError** error)
{
    GError* _inner_error_ = NULL;

    TaskManagerDispatcher* self = (TaskManagerDispatcher*) base;
    g_return_if_fail(win_name != NULL);
    GHashTable* hints = g_hash_table_new_full(g_str_hash, g_str_equal, _g_free0_, __vala_GValue_free0_);
    char* _tmp1_ = g_strdup("visible");
    GValue* _tmp2_ = g_new0(GValue, 1);
    g_value_init(_tmp2_, G_TYPE_BOOLEAN);
    g_value_set_boolean(_tmp2_, visible);
    g_hash_table_insert(hints, _tmp1_, _tmp2_);

    GValue _tmp3_ = {0};
    g_value_init(&_tmp3_, G_TYPE_STRING);
    g_value_set_string(&_tmp3_, win_name);
    task_manager_update(self->priv->_manager, &_tmp3_, hints, &_inner_error_);
    G_IS_VALUE(&_tmp3_) ? (g_value_unset(&_tmp3_), NULL) : NULL;
    if (_inner_error_ != NULL) {
        if (_inner_error_->domain == DBUS_GERROR) {
            g_propagate_error(error, _inner_error_);
            _g_hash_table_unref0(hints);
            return;
        } else {
            _g_hash_table_unref0(hints);
            g_critical("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string(_inner_error_->domain), _inner_error_->code);
            g_clear_error(&_inner_error_);
            return;
        }
    }
    _g_hash_table_unref0(hints);
}


static char* task_manager_dispatcher_real_awn_register_proxy_item(DockManagerDBusInterface* base, const gchar* desktop_file, const gchar* uri, GError** error)
{
    TaskManagerDispatcher* self = (TaskManagerDispatcher*) base;
    g_return_val_if_fail(desktop_file != NULL, NULL);
    g_return_val_if_fail(uri != NULL, NULL);
    return g_strdup("/not/yet/implemented");
}


TaskManager* task_manager_dispatcher_get_manager(TaskManagerDispatcher* self)
{
    g_return_val_if_fail(self != NULL, NULL);
    return self->priv->_manager;
}


static gpointer _g_object_ref0(gpointer self)
{
    return self ? g_object_ref(self) : NULL;
}


static void task_manager_dispatcher_set_manager(TaskManagerDispatcher* self, TaskManager* value)
{
    g_return_if_fail(self != NULL);
    TaskManager* tmp = _g_object_ref0(value);
    _g_object_unref0(self->priv->_manager);
    self->priv->_manager = tmp;
    g_object_notify((GObject*) self, "manager");
}


static void task_manager_dispatcher_class_init(TaskManagerDispatcherClass* klass)
{
    task_manager_dispatcher_parent_class = g_type_class_peek_parent(klass);
    g_type_class_add_private(klass, sizeof(TaskManagerDispatcherPrivate));
    G_OBJECT_CLASS(klass)->get_property = _vala_task_manager_dispatcher_get_property;
    G_OBJECT_CLASS(klass)->set_property = _vala_task_manager_dispatcher_set_property;
    G_OBJECT_CLASS(klass)->finalize = task_manager_dispatcher_finalize;
    g_object_class_install_property(G_OBJECT_CLASS(klass), TASK_MANAGER_DISPATCHER_MANAGER, g_param_spec_object("manager", "manager", "manager", TASK_TYPE_MANAGER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void task_manager_dispatcher_dock_manager_dbus_interface_interface_init(DockManagerDBusInterfaceIface* iface)
{
    task_manager_dispatcher_dock_manager_dbus_interface_parent_iface = g_type_interface_peek_parent(iface);
    iface->get_capabilities = (gchar** (*)(DockManagerDBusInterface* , int* , GError**)) task_manager_dispatcher_real_get_capabilities;
    iface->get_items = (char** (*)(DockManagerDBusInterface* , int* , GError**)) task_manager_dispatcher_real_get_items;
    iface->get_items_by_name = (char** (*)(DockManagerDBusInterface* , const gchar* , int* , GError**)) task_manager_dispatcher_real_get_items_by_name;
    iface->get_items_by_desktop_file = (char** (*)(DockManagerDBusInterface* , const gchar* , int* , GError**)) task_manager_dispatcher_real_get_items_by_desktop_file;
    iface->get_items_by_pid = (char** (*)(DockManagerDBusInterface* , gint , int* , GError**)) task_manager_dispatcher_real_get_items_by_pid;
    iface->get_item_by_xid = (char * (*)(DockManagerDBusInterface* , gint64 , GError**)) task_manager_dispatcher_real_get_item_by_xid;
    iface->awn_set_visibility = (void (*)(DockManagerDBusInterface* , const gchar* , gboolean , GError**)) task_manager_dispatcher_real_awn_set_visibility;
    iface->awn_register_proxy_item = (char * (*)(DockManagerDBusInterface* , const gchar* , const gchar* , GError**)) task_manager_dispatcher_real_awn_register_proxy_item;
}


static void task_manager_dispatcher_instance_init(TaskManagerDispatcher* self)
{
    self->priv = TASK_MANAGER_DISPATCHER_GET_PRIVATE(self);
}


static void task_manager_dispatcher_finalize(GObject* obj)
{
    TaskManagerDispatcher* self = TASK_MANAGER_DISPATCHER(obj);
    _g_object_unref0(self->priv->_manager);
    G_OBJECT_CLASS(task_manager_dispatcher_parent_class)->finalize(obj);
}


void _task_manager_dispatcher_dbus_unregister(DBusConnection* connection, void* _user_data_)
{
}


static DBusHandlerResult _dbus_task_manager_dispatcher_introspect(TaskManagerDispatcher* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    std::string xml_data{"<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n"};
    xml_data +=  "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"net.launchpad.DockManager\">\n  <method name=\"GetCapabilities\">\n    <arg name=\"result\" type=\"as\" direction=\"out\"/>\n  </method>\n  <method name=\"GetItems\">\n    <arg name=\"result\" type=\"ao\" direction=\"out\"/>\n  </method>\n  <method name=\"GetItemsByName\">\n    <arg name=\"name\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"ao\" direction=\"out\"/>\n  </method>\n  <method name=\"GetItemsByDesktopFile\">\n    <arg name=\"desktop_file\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"ao\" direction=\"out\"/>\n  </method>\n  <method name=\"GetItemsByPid\">\n    <arg name=\"pid\" type=\"i\" direction=\"in\"/>\n    <arg name=\"result\" type=\"ao\" direction=\"out\"/>\n  </method>\n  <method name=\"GetItemByXid\">\n    <arg name=\"xid\" type=\"x\" direction=\"in\"/>\n    <arg name=\"result\" type=\"o\" direction=\"out\"/>\n  </method>\n  <method name=\"AwnSetVisibility\">\n    <arg name=\"win_name\" type=\"s\" direction=\"in\"/>\n    <arg name=\"visible\" type=\"b\" direction=\"in\"/>\n  </method>\n  <method name=\"AwnRegisterProxyItem\">\n    <arg name=\"desktop_file\" type=\"s\" direction=\"in\"/>\n    <arg name=\"uri\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"o\" direction=\"out\"/>\n  </method>\n  <signal name=\"ItemAdded\">\n    <arg name=\"path\" type=\"o\"/>\n  </signal>\n  <signal name=\"ItemRemoved\">\n    <arg name=\"path\" type=\"o\"/>\n  </signal>\n</interface>\n";

    char** children;
    dbus_connection_list_registered(connection, g_object_get_data((GObject*) self, "dbus_object_path"), &children);
    for (int i = 0; children[i]; i++) {
        xml_data = xml_data + "<node name=\"" + children[i] + "\"/>\n";
    }
    dbus_free_string_array(children);
    xml_data += "</node>\n";
    awn::vala_dbus_iter_append_string(&iter, xml_data.c_str());
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


DBusHandlerResult task_manager_dispatcher_dbus_message(DBusConnection* connection, DBusMessage* message, void* object)
{
    DBusHandlerResult result;
    result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    if (dbus_message_is_method_call(message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
        result = _dbus_task_manager_dispatcher_introspect(object, connection, message);
    }
    if (result == DBUS_HANDLER_RESULT_HANDLED) {
        return result;
    } else if (dock_manager_dbus_interface_dbus_message(connection, message, object) == DBUS_HANDLER_RESULT_HANDLED) {
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


void task_manager_dispatcher_dbus_register_object(DBusConnection* connection, const char* path, void* object)
{
    if (!g_object_get_data(object, "dbus_object_path")) {
        g_object_set_data(object, "dbus_object_path", g_strdup(path));
        dbus_connection_register_object_path(connection, path, &_task_manager_dispatcher_dbus_path_vtable, object);
        g_object_weak_ref(object, _vala_dbus_unregister_object, connection);
    }
    dock_manager_dbus_interface_dbus_register_object(connection, path, object);
}


GType task_manager_dispatcher_get_type(void)
{
    static volatile gsize task_manager_dispatcher_type_id__volatile = 0;
    if (g_once_init_enter(&task_manager_dispatcher_type_id__volatile)) {
        static const GTypeInfo g_define_type_info = { sizeof(TaskManagerDispatcherClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) task_manager_dispatcher_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof(TaskManagerDispatcher), 0, (GInstanceInitFunc) task_manager_dispatcher_instance_init, NULL };
        static const GInterfaceInfo dock_manager_dbus_interface_info = { (GInterfaceInitFunc) task_manager_dispatcher_dock_manager_dbus_interface_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
        GType task_manager_dispatcher_type_id;
        task_manager_dispatcher_type_id = g_type_register_static(G_TYPE_OBJECT, "TaskManagerDispatcher", &g_define_type_info, 0);
        g_type_add_interface_static(task_manager_dispatcher_type_id, TYPE_DOCK_MANAGER_DBUS_INTERFACE, &dock_manager_dbus_interface_info);
        g_type_set_qdata(task_manager_dispatcher_type_id, g_quark_from_static_string("DBusObjectVTable"), (void*)(&_task_manager_dispatcher_dbus_vtable));
        g_once_init_leave(&task_manager_dispatcher_type_id__volatile, task_manager_dispatcher_type_id);
    }
    return task_manager_dispatcher_type_id__volatile;
}


static void _vala_task_manager_dispatcher_get_property(GObject* object, guint property_id, GValue* value, GParamSpec* pspec)
{
    TaskManagerDispatcher* self = TASK_MANAGER_DISPATCHER(object);
    switch (property_id) {
    case TASK_MANAGER_DISPATCHER_MANAGER:
        g_value_set_object(value, task_manager_dispatcher_get_manager(self));
        break;
    default:
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}


static void _vala_task_manager_dispatcher_set_property(GObject* object, guint property_id, const GValue* value, GParamSpec* pspec)
{
    TaskManagerDispatcher* self = TASK_MANAGER_DISPATCHER(object);
    switch (property_id) {
    case TASK_MANAGER_DISPATCHER_MANAGER:
        task_manager_dispatcher_set_manager(self, g_value_get_object(value));
        break;
    default:
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}


TaskIconDispatcher* task_icon_dispatcher_construct(GType object_type, TaskIcon* icon)
{
    GError* _inner_error_ = NULL;
    g_return_val_if_fail(icon != NULL, NULL);
    TaskIconDispatcher* self = (TaskIconDispatcher*) g_object_new(object_type, NULL);
    self->priv->icon = icon;
    DBusGConnection* conn = dbus_g_bus_get(DBUS_BUS_SESSION, &_inner_error_);
    if (_inner_error_ != NULL) {
        g_critical("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string(_inner_error_->domain), _inner_error_->code);
        g_clear_error(&_inner_error_);
        return NULL;
    }
    task_icon_dispatcher_counter++;
    char* path = g_strdup_printf("/net/launchpad/DockManager/Item%d", task_icon_dispatcher_counter);
    task_icon_dispatcher_set_object_path(self, path);
    _vala_dbus_register_object(dbus_g_connection_get_connection(conn), self->priv->_object_path, (GObject*) self);
    task_icon_dispatcher_emit_item_added(self);
    _dbus_g_connection_unref0(conn);
    return self;
}


TaskIconDispatcher* task_icon_dispatcher_new(TaskIcon* icon)
{
    return task_icon_dispatcher_construct(TYPE_TASK_ICON_DISPATCHER, icon);
}


static TaskManagerDispatcher* task_icon_dispatcher_get_manager_proxy(TaskIconDispatcher* self)
{    
    g_return_val_if_fail(self != NULL, NULL);
    AwnApplet* applet = task_icon_get_applet(self->priv->icon);
    TaskManager* manager = TASK_IS_MANAGER(applet) ? ((TaskManager*) applet) : NULL;
    GObject* tmp_obj = task_manager_get_dbus_dispatcher(manager);
    return IS_TASK_MANAGER_DISPATCHER(tmp_obj) ? ((TaskManagerDispatcher*) tmp_obj) : NULL;
}


static void task_icon_dispatcher_emit_item_added(TaskIconDispatcher* self)
{
    g_return_if_fail(self != NULL);
    TaskManagerDispatcher* proxy = task_icon_dispatcher_get_manager_proxy(self);
    if (proxy != nullptr) {
        g_signal_emit_by_name((DockManagerDBusInterface*) proxy, "item-added",
                              self->priv->_object_path);
    }
}


static Block1Data* block1_data_ref(Block1Data* _data1_)
{
    g_atomic_int_inc(&_data1_->_ref_count_);
    return _data1_;
}


static void block1_data_unref(Block1Data* _data1_)
{
    if (g_atomic_int_dec_and_test(&_data1_->_ref_count_)) {
        _g_object_unref0(_data1_->self);
        g_slice_free(Block1Data, _data1_);
    }
}


static void _lambda0_(GtkMenuItem* w, Block1Data* _data1_)
{
    TaskIconDispatcher* self = _data1_->self;
    g_return_if_fail(w != NULL);
    g_signal_emit_by_name((DockItemDBusInterface*) self, "menu-item-activated", _data1_->id);
}


static void __lambda0__gtk_menu_item_activate(GtkMenuItem* _sender, gpointer self)
{
    _lambda0_(_sender, self);
}


static gint task_icon_dispatcher_real_add_menu_item(DockItemDBusInterface* base, GHashTable* menu_hints, GError** error)
{
    gint result = 0;
    GtkImageMenuItem* item = nullptr;
    GtkImage* image = nullptr;
    gchar* group = nullptr;
    GError* _inner_error_ = NULL;

    TaskIconDispatcher* self = (TaskIconDispatcher*) base;
    g_return_val_if_fail(menu_hints != NULL, 0);

    GHashTableIter iter = {0};
    g_hash_table_iter_init(&iter, menu_hints);
    while (TRUE) {
        const char* key;
        GValue* value;

        bool found = g_hash_table_iter_next(&iter, &key, &value);
        if (!found) {
            break;
        }
        if (g_strcmp0(key, "label") == 0) {
            const gchar* _tmp3_ = NULL;
            GtkImageMenuItem* _tmp4_ = NULL;
            _tmp3_ = g_value_get_string(value);
            item = (GtkImageMenuItem*) gtk_image_menu_item_new_with_label(_tmp3_);
            item = g_object_ref_sink(item);
        } else {
            if (g_strcmp0(key, "icon-name") == 0) {
                const gchar* _tmp5_ = NULL;
                GtkImage* _tmp6_ = NULL;
                _tmp5_ = g_value_get_string(value);
                image = (GtkImage*) gtk_image_new_from_icon_name(_tmp5_, GTK_ICON_SIZE_MENU);
                image = g_object_ref_sink(image);
            } else {
                if (g_strcmp0(key, "icon-file") == 0) {
                    int w, h;
                    gtk_icon_size_lookup(GTK_ICON_SIZE_MENU, &w, &h);
                    const gchar* _tmp9_ = g_value_get_string(value);
                    GdkPixbuf* pixbuf = gdk_pixbuf_new_from_file_at_size(_tmp9_, w, h, &_inner_error_);
                    if (_inner_error_ != NULL) {
                        g_warning("dock-manager-api.vala:316: %s", _inner_error_->message);
                        _g_error_free0(_inner_error_);
                        _inner_error_ = nullptr;
                    } else {
                        image = (GtkImage*) gtk_image_new_from_pixbuf(pixbuf);
                        image = g_object_ref_sink(image);
                    }
                    _g_object_unref0(pixbuf);
                } else {
                    if (g_strcmp0(key, "container-title") == 0) {
                        const gchar* _tmp13_ = NULL;
                        gchar* _tmp14_;
                        _tmp13_ = g_value_get_string(value);
                        _tmp14_ = g_strdup(_tmp13_);
                        _g_free0(group);
                        group = _tmp14_;
                    } else {
                        if (g_strcmp0(key, "uri") == 0) {
                        }
                    }
                }
            }
        }
    }
    if (item != NULL) {
        Block1Data* _data1_ = g_slice_new0(Block1Data);
        _data1_->_ref_count_ = 1;
        _data1_->self = g_object_ref(self);
        if (image != nullptr) {
            gtk_image_menu_item_set_image(item, (GtkWidget*) image);
        }
        _data1_->id = task_icon_add_menu_item(self->priv->icon, (GtkMenuItem*) item, group);
        gtk_widget_show((GtkWidget*) item);
        g_signal_connect_data((GtkMenuItem*) item, "activate", (GCallback) __lambda0__gtk_menu_item_activate, block1_data_ref(_data1_), (GClosureNotify) block1_data_unref, 0);
        result = _data1_->id;
        block1_data_unref(_data1_);
        _data1_ = NULL;
        _g_free0(group);
        _g_object_unref0(image);
        _g_object_unref0(item);
        return result;
    }
    _g_free0(group);
    _g_object_unref0(image);
    _g_object_unref0(item);
    return 0;
}


static void task_icon_dispatcher_real_remove_menu_item(DockItemDBusInterface* base, gint id, GError** error)
{
    TaskIconDispatcher* self = (TaskIconDispatcher*) base;
    task_icon_remove_menu_item(self->priv->icon, id);
}


static void task_icon_dispatcher_real_update_dock_item(DockItemDBusInterface* base, GHashTable* hints, GError** error)
{
    TaskIconDispatcher* self = (TaskIconDispatcher*) base;
    GHashTableIter iter = {0};

    g_return_if_fail(hints != NULL);
    g_hash_table_iter_init(&iter, hints);

    while (true) {

        const gchar* key;
        GValue* value;

        if (!g_hash_table_iter_next(&iter, &key, &value)) {
            break;
        }
        GSList* items = task_icon_get_items(self->priv->icon);
        {
            GSList* item_collection = items;
            for (GSList* item_it = item_collection; item_it != nullptr;
                item_it = item_it->next) {
                TaskItem* item = (TaskItem*) item_it->data;
                {
                    if (TASK_IS_LAUNCHER(item)) {
                        continue;
                    }
                    task_item_update_overlay(item, key, value);
                }
            }
        }
    }
}


const gchar* task_icon_dispatcher_get_object_path(TaskIconDispatcher* self)
{
    g_return_val_if_fail(self != NULL, NULL);
    return self->priv->_object_path;
}


void task_icon_dispatcher_set_object_path(TaskIconDispatcher* self, const gchar* value)
{
    g_return_if_fail(self != NULL);
    g_free(self->priv->_object_path);
    self->priv->_object_path = g_strdup(value);
    g_object_notify((GObject*) self, "object-path");
}


static gchar* string_replace(const gchar* self, const gchar* old, const gchar* replacement)
{
    GError* _inner_error_ = NULL;
    g_return_val_if_fail(self != NULL, NULL);
    g_return_val_if_fail(old != NULL, NULL);
    g_return_val_if_fail(replacement != NULL, NULL);

    char* _tmp1_ = g_regex_escape_string(old, -1);
    GRegex* regex = g_regex_new(_tmp1_, 0, 0, &_inner_error_);
    _g_free0(_tmp1_);

    char* result;

    if (_inner_error_ != NULL) {
        if (_inner_error_->domain == G_REGEX_ERROR) {
            goto __catch1_g_regex_error;
        }
        g_critical("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string(_inner_error_->domain), _inner_error_->code);
        g_clear_error(&_inner_error_);
        return NULL;
    }
    result = g_regex_replace_literal(regex, self, (gssize)(-1), 0, replacement, 0, &_inner_error_);
    if (_inner_error_ != NULL) {
        _g_regex_unref0(regex);
        if (_inner_error_->domain == G_REGEX_ERROR) {
            goto __catch1_g_regex_error;
        }
        _g_regex_unref0(regex);
        g_critical("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string(_inner_error_->domain), _inner_error_->code);
        g_clear_error(&_inner_error_);
        return NULL;
    }
    _g_regex_unref0(regex);
    return result;

__catch1_g_regex_error: {
        GError* e = _inner_error_;
        _inner_error_ = NULL;
        g_assert_not_reached();
        _g_error_free0(e);
    }
    if (_inner_error_ != NULL) {
        g_critical("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string(_inner_error_->domain), _inner_error_->code);
        g_clear_error(&_inner_error_);
        return NULL;
    }
}


static gchar* task_icon_dispatcher_real_get_desktop_file(DockItemDBusInterface* base)
{
    TaskIconDispatcher* self = (TaskIconDispatcher*) base;

    TaskItem* item = task_icon_get_launcher(self->priv->icon);
    if (!TASK_IS_LAUNCHER(item)) {
        return g_strdup("");
    }

    TaskLauncher* launcher = (TaskLauncher*) item;
    return string_replace(task_launcher_get_desktop_path(launcher), "//", "/");
}


static gchar* task_icon_dispatcher_real_get_uri(DockItemDBusInterface* base)
{
    return g_strdup("");
}


static void task_icon_dispatcher_class_init(TaskIconDispatcherClass* klass)
{
    task_icon_dispatcher_parent_class = g_type_class_peek_parent(klass);
    g_type_class_add_private(klass, sizeof(TaskIconDispatcherPrivate));
    G_OBJECT_CLASS(klass)->get_property = _vala_task_icon_dispatcher_get_property;
    G_OBJECT_CLASS(klass)->set_property = _vala_task_icon_dispatcher_set_property;
    G_OBJECT_CLASS(klass)->finalize = task_icon_dispatcher_finalize;
    g_object_class_install_property(G_OBJECT_CLASS(klass), TASK_ICON_DISPATCHER_OBJECT_PATH, g_param_spec_string("object-path", "object-path", "object-path", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void task_icon_dispatcher_dock_item_dbus_interface_interface_init(DockItemDBusInterfaceIface* iface)
{
    task_icon_dispatcher_dock_item_dbus_interface_parent_iface = g_type_interface_peek_parent(iface);
    iface->add_menu_item = (gint(*)(DockItemDBusInterface* , GHashTable* , GError**)) task_icon_dispatcher_real_add_menu_item;
    iface->remove_menu_item = (void (*)(DockItemDBusInterface* , gint , GError**)) task_icon_dispatcher_real_remove_menu_item;
    iface->update_dock_item = (void (*)(DockItemDBusInterface* , GHashTable* , GError**)) task_icon_dispatcher_real_update_dock_item;
    iface->get_desktop_file = task_icon_dispatcher_real_get_desktop_file;
    iface->get_uri = task_icon_dispatcher_real_get_uri;
}


static void task_icon_dispatcher_instance_init(TaskIconDispatcher* self)
{
    self->priv = TASK_ICON_DISPATCHER_GET_PRIVATE(self);
}


static void task_icon_dispatcher_finalize(GObject* obj)
{
    TaskIconDispatcher* self = TASK_ICON_DISPATCHER(obj);
    TaskManagerDispatcher* proxy = task_icon_dispatcher_get_manager_proxy(self);
    if (proxy != NULL) {
        g_signal_emit_by_name((DockManagerDBusInterface*) proxy, "item-removed",
                              self->priv->_object_path);
    }
    g_free(self->priv->_object_path);
    G_OBJECT_CLASS(task_icon_dispatcher_parent_class)->finalize(obj);
}


void _task_icon_dispatcher_dbus_unregister(DBusConnection* connection, void* _user_data_)
{
}


static DBusHandlerResult _dbus_task_icon_dispatcher_introspect(TaskIconDispatcher* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    char** children;
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    std::string xml_data{"<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n"};
    xml_data += "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"net.launchpad.DockItem\">\n  <method name=\"AddMenuItem\">\n    <arg name=\"menu_hints\" type=\"a{sv}\" direction=\"in\"/>\n    <arg name=\"result\" type=\"i\" direction=\"out\"/>\n  </method>\n  <method name=\"RemoveMenuItem\">\n    <arg name=\"id\" type=\"i\" direction=\"in\"/>\n  </method>\n  <method name=\"UpdateDockItem\">\n    <arg name=\"hints\" type=\"a{sv}\" direction=\"in\"/>\n  </method>\n  <property name=\"DesktopFile\" type=\"s\" access=\"read\"/>\n  <property name=\"Uri\" type=\"s\" access=\"read\"/>\n  <signal name=\"MenuItemActivated\">\n    <arg name=\"id\" type=\"i\"/>\n  </signal>\n</interface>\n";
    dbus_connection_list_registered(connection, g_object_get_data((GObject*) self, "dbus_object_path"), &children);
    for (int i = 0; children[i]; i++) {
        xml_data = xml_data + "<node name=\"" + children[i] + "\"/>\n";
    }
    dbus_free_string_array(children);
    xml_data += "</node>\n";
    awn::vala_dbus_iter_append_string(&iter, xml_data.c_str());
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


DBusHandlerResult task_icon_dispatcher_dbus_message(DBusConnection* connection, DBusMessage* message, void* object)
{
    DBusHandlerResult result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    if (dbus_message_is_method_call(message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
        result = _dbus_task_icon_dispatcher_introspect(object, connection, message);
    }
    if (result == DBUS_HANDLER_RESULT_HANDLED) {
        return result;
    } else if (dock_item_dbus_interface_dbus_message(connection, message, object) == DBUS_HANDLER_RESULT_HANDLED) {
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


void task_icon_dispatcher_dbus_register_object(DBusConnection* connection, const char* path, void* object)
{
    if (!g_object_get_data(object, "dbus_object_path")) {
        g_object_set_data(object, "dbus_object_path", g_strdup(path));
        dbus_connection_register_object_path(connection, path, &_task_icon_dispatcher_dbus_path_vtable, object);
        g_object_weak_ref(object, _vala_dbus_unregister_object, connection);
    }
    dock_item_dbus_interface_dbus_register_object(connection, path, object);
}


GType task_icon_dispatcher_get_type(void)
{
    static volatile gsize task_icon_dispatcher_type_id__volatile = 0;
    if (g_once_init_enter(&task_icon_dispatcher_type_id__volatile)) {
        static const GTypeInfo g_define_type_info = { sizeof(TaskIconDispatcherClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) task_icon_dispatcher_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof(TaskIconDispatcher), 0, (GInstanceInitFunc) task_icon_dispatcher_instance_init, NULL };
        static const GInterfaceInfo dock_item_dbus_interface_info = { (GInterfaceInitFunc) task_icon_dispatcher_dock_item_dbus_interface_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
        GType task_icon_dispatcher_type_id;
        task_icon_dispatcher_type_id = g_type_register_static(G_TYPE_OBJECT, "TaskIconDispatcher", &g_define_type_info, 0);
        g_type_add_interface_static(task_icon_dispatcher_type_id, TYPE_DOCK_ITEM_DBUS_INTERFACE, &dock_item_dbus_interface_info);
        g_type_set_qdata(task_icon_dispatcher_type_id, g_quark_from_static_string("DBusObjectVTable"), (void*)(&_task_icon_dispatcher_dbus_vtable));
        g_once_init_leave(&task_icon_dispatcher_type_id__volatile, task_icon_dispatcher_type_id);
    }
    return task_icon_dispatcher_type_id__volatile;
}


static void _vala_task_icon_dispatcher_get_property(GObject* object, guint property_id, GValue* value, GParamSpec* pspec)
{
    TaskIconDispatcher* self = TASK_ICON_DISPATCHER(object);
    switch (property_id) {
    case TASK_ICON_DISPATCHER_OBJECT_PATH:
        g_value_set_string(value, task_icon_dispatcher_get_object_path(self));
        break;
    default:
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}


static void _vala_task_icon_dispatcher_set_property(GObject* object, guint property_id, const GValue* value, GParamSpec* pspec)
{
    TaskIconDispatcher* self = TASK_ICON_DISPATCHER(object);
    switch (property_id) {
    case TASK_ICON_DISPATCHER_OBJECT_PATH:
        task_icon_dispatcher_set_object_path(self, g_value_get_string(value));
        break;
    default:
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}
